--[[
	THE MIST HUB - Professional Key System GUI (Silent)
	Ultra-Modern Design with Full Key Validation Logic
]]

-- ================================================================= --
-- [ Section 1: Pre-Flight Check & Failsafe ]
-- ================================================================= --

if JunkieProtected == nil then
	local player = game:GetService("Players").LocalPlayer
	if not player or not player:IsA("Player") then return end
	local failsafeGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
	failsafeGui.Name = "MistHub_FAILSAFE"
	failsafeGui.ResetOnSpawn = false
	local background = Instance.new("Frame", failsafeGui)
	background.BackgroundColor3 = Color3.fromRGB(31, 31, 31)
	background.BorderColor3 = Color3.fromRGB(255, 60, 60)
	background.BorderSizePixel = 2
	background.Position = UDim2.fromScale(0.5, 0.5)
	background.AnchorPoint = Vector2.new(0.5, 0.5)
	background.Size = UDim2.new(0, 500, 0, 300)
	Instance.new("UICorner", background).CornerRadius = UDim.new(0, 12)
	local title = Instance.new("TextLabel", background)
	title.Size = UDim2.new(1, 0, 0, 50)
	title.BackgroundColor3 = Color3.fromRGB(255, 60, 60)
	title.TextColor3 = Color3.fromRGB(255, 255, 255)
	title.Font = Enum.Font.GothamBold
	title.TextSize = 24
	title.Text = "SDK INITIALIZATION FAILED"
	Instance.new("UICorner", title).CornerRadius = UDim.new(0, 10)
	local message = Instance.new("TextLabel", background)
	message.Size = UDim2.new(0.9, 0, 0.7, 0)
	message.Position = UDim2.fromScale(0.05, 0.25)
	message.BackgroundTransparency = 1
	message.TextColor3 = Color3.fromRGB(240, 240, 240)
	message.Font = Enum.Font.Gotham
	message.TextSize = 18
	message.TextWrapped = true
	message.TextXAlignment = Enum.TextXAlignment.Left
	message.Text = "The protection library was not found.\n\nPlease ensure you are using the official script version obtained after processing it through the dashboard."
	return
end

-- ================================================================= --
-- SERVICES & CONFIG
-- ================================================================= --

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

JunkieProtected.API_KEY = "f2896b56-b3d0-4428-8660-50264327d813"
JunkieProtected.PROVIDER = "key_system"
JunkieProtected.SERVICE_ID = "key system"

local KEY_FILENAME = "MistHubKey.txt"

-- ================================================================= --
-- RUN MAIN SCRIPT FUNCTION
-- ================================================================= --

local function RunMainScript()
	-- ▼▼▼ PASTE YOUR MAIN SCRIPT CODE HERE ▼▼▼

local GUI_BASE_WIDTH = 413.5
local GUI_BASE_HEIGHT = 450
local GUI_SIZE_MULTIPLIER = 1.1

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local GuiService = game:GetService("GuiService")
local CoreGui = game:GetService("CoreGui")
local Camera = workspace.CurrentCamera
local gameDefaultFOV = Camera.FieldOfView
local Debris = game:GetService("Debris")
local SoundService = game:GetService("SoundService")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local backpack = player:WaitForChild("Backpack")
local playerGui = player:WaitForChild("PlayerGui")
local isAutoTargetEnabled = true; local lastShotTime = 0;
local COOLDOWN = 0.5;
local targetingFOV = 35;
local currentDelayMode = "Blatant"
local shootDelayMilliseconds = 0
local fovCircle = nil;
local excludedPlayers = {};
local isStealthMode = true
local isESPEnabled = false;
local isFOVChangerEnabled = false;
local defaultScriptFOV = 115;
local currentCameraFOV = gameDefaultFOV;
local currentTool = nil
local activatedConnection = nil
local currentEffectiveCooldown = 0
local excludeMethod = "Player List"
local createBeautifulGUI
local updateFOVCircle, updateAllExcludedLabelsVisibility, toggleESP, setSliderEnabled, setSliderValue, updateExcludedLabel, setupToolListener, calculateEffectiveCooldown, findTool
local BulletRenderer_upvr = nil
local successBulletRenderer, errBulletRenderer = pcall(function()
	local modulesFolder = ReplicatedStorage:FindFirstChild("Modules")
	if modulesFolder and modulesFolder:FindFirstChild("BulletRenderer") then
		BulletRenderer_upvr = require(modulesFolder.BulletRenderer)
	end
end)
local THEME = { Background = Color3.fromRGB(18, 18, 22), BackgroundSlightlyLighter = Color3.fromRGB(24, 24, 28), BackgroundSubtleVariant = Color3.fromRGB(21, 21, 25), Primary = Color3.fromRGB(35, 35, 45), PrimaryLighter = Color3.fromRGB(45, 45, 55), Secondary = Color3.fromRGB(55, 55, 65), Tertiary = Color3.fromRGB(75, 75, 85), Accent = Color3.fromRGB(0, 180, 180), AccentAlt = Color3.fromRGB(0, 140, 140), AccentDarkRed = Color3.fromRGB(180, 40, 50), Text = Color3.fromRGB(235, 235, 245), TextActive = Color3.fromRGB(255, 255, 255), TextDisabled = Color3.fromRGB(110, 110, 120), TextPlayerListNormal = Color3.fromRGB(240, 240, 250), Success = Color3.fromRGB(30, 200, 130), Error = Color3.fromRGB(250, 60, 80), ExcludedIcon = Color3.fromRGB(250, 60, 80), Tooltip = Color3.fromRGB(8, 8, 10), ButtonText = Color3.fromRGB(240, 240, 250), ButtonBackground = Color3.fromRGB(35, 35, 45), ButtonBackgroundHover = Color3.fromRGB(45, 45, 55), ButtonOutline = Color3.fromRGB(75, 75, 85), ButtonOutlineHover = Color3.fromRGB(0, 180, 180), SliderTrack = Color3.fromRGB(55, 55, 65), SliderTrackDisabled = Color3.fromRGB(35, 35, 45), SliderThumbBorder = Color3.fromRGB(18, 18, 22), SliderThumbBorderDisabled = Color3.fromRGB(35, 35, 45), ExcludeLabelBg = Color3.fromRGB(50, 10, 50), ExcludeLabelOutline = Color3.fromRGB(220, 220, 220), Font = Enum.Font.GothamSemibold, FontTitle = Enum.Font.GothamBold, FontIcon = Enum.Font.SourceSansBold, FontRegular = Enum.Font.Gotham, TextSize = 11, SmallTextSize = 9, TitleSize = 12, IconSize = 14, SubtitleSize = 8, DisclaimerSize = 7, CornerRadius = 6, Padding = 6, ElementHeight = 24, SmallElementHeight = 20, SliderHeight = 4, SliderThumbSize = 12, PanelMinWidth = 190, PanelMaxWidth = 285, AnimationSpeed = 0.2, ScaleFactorHover = 1.02, ScaleFactorPress = 0.98, StrokeThickness = 1, ButtonOutlineThickness = 1.5, StrokeTransparency = 0.6, StrokeTransparencyHover = 0.4, RefExcludedColor = Color3.fromRGB(255, 0, 0), RefFOVCircleColor = Color3.fromRGB(128, 0, 128), TextColorFadeDuration = 0.25 }
local TextColorTweenInfo = TweenInfo.new(THEME.TextColorFadeDuration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut); local DimTweenInfo = TweenInfo.new(THEME.AnimationSpeed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out);
local SwitchAnimationInfo = TweenInfo.new(0.25, Enum.EasingStyle.Cubic, Enum.EasingDirection.Out)
local Storage = Instance.new("Folder", CoreGui) Storage.Name = "TheMist_Storage_DelaySwitcher_V24"
local function cleanupOldStorage() for _, v in ipairs(CoreGui:GetChildren()) do if v:IsA("Folder") and v.Name:match("Storage") and v ~= Storage then v:Destroy() end end end; cleanupOldStorage()
local GuiElements = {}
local TooltipLabel = nil
local mainFrame = nil
local panelVisible = false
function calculateEffectiveCooldown(toolInstance)
	if not toolInstance or not toolInstance:IsA("Tool") then return COOLDOWN end
	local gameCooldown = toolInstance:GetAttribute("Cooldown")
	return (type(gameCooldown) == "number" and gameCooldown > 0) and gameCooldown or COOLDOWN
end
function createDrawingCircle()
	if not pcall(function() local _ = Drawing.new end) then return nil end
	local circle = Drawing.new("Circle")
	circle.Thickness = 2
	circle.Color = THEME.RefFOVCircleColor
	circle.Transparency = 0.5
	circle.Filled = false
	circle.NumSides = 64
	circle.Visible = false
	return circle
end
function updateFOVCircle()
	if not fovCircle then return end
	local shouldBeVisible = isAutoTargetEnabled and (not isStealthMode or panelVisible)
	fovCircle.Visible = shouldBeVisible
	if not shouldBeVisible then return end
	local screenSize = Camera.ViewportSize
	if not screenSize or screenSize.X == 0 or screenSize.Y == 0 then fovCircle.Visible = false; return end
	fovCircle.Position = screenSize / 2
	local fovRad = math.rad(targetingFOV / 2)
	local camFovRad = math.rad(Camera.FieldOfView / 2)
	if fovRad <= 0 or camFovRad <= 0 or math.tan(camFovRad) == 0 then fovCircle.Visible = false; return end
	local radius = (screenSize.Y / 2) * math.tan(fovRad) / math.tan(camFovRad)
	fovCircle.Radius = math.max(0, radius)
end
function updateExcludedLabel(targetPlayer)
	local char = targetPlayer.Character
	if not char or not char:FindFirstChild("Head") then return end
	local head = char.Head
	local billboard = head:FindFirstChild("ExcludeLabel")
	local isExcluded = excludedPlayers[targetPlayer]
	if isExcluded then
		if not billboard then
			billboard = Instance.new("BillboardGui", head)
			billboard.Name = "ExcludeLabel"
			billboard.Size = UDim2.new(0, 85, 0, 22)
			billboard.StudsOffset = Vector3.new(0, 2.4, 0)
			billboard.AlwaysOnTop = true
			billboard.LightInfluence = 0
			billboard.ClipsDescendants = true
			local textLabel = Instance.new("TextLabel", billboard)
			textLabel.Size = UDim2.fromScale(1, 1)
			textLabel.BackgroundColor3 = THEME.ExcludeLabelBg
			textLabel.BackgroundTransparency = 0.2
			textLabel.Font = Enum.Font.GothamSemibold
			textLabel.Text = "EXCLUDED"
			textLabel.TextColor3 = THEME.RefExcludedColor
			textLabel.TextSize = 11
			textLabel.TextScaled = false
			textLabel.TextXAlignment = Enum.TextXAlignment.Center
			textLabel.TextYAlignment = Enum.TextYAlignment.Center
			local corner = Instance.new("UICorner", textLabel)
			corner.CornerRadius = UDim.new(0, 3)
			local stroke = Instance.new("UIStroke", textLabel)
			stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			stroke.Color = THEME.ExcludeLabelOutline
			stroke.Thickness = 1
			stroke.Transparency = 0.3
		end
		billboard.Enabled = (not isStealthMode or panelVisible)
	else
		if billboard then billboard:Destroy() end
	end
end
function updateAllExcludedLabelsVisibility()
	local desiredVisibility = (not isStealthMode or panelVisible)
	for plr, _ in pairs(excludedPlayers) do
		if plr and plr.Character and plr.Character:FindFirstChild("Head") then
			local billboard = plr.Character.Head:FindFirstChild("ExcludeLabel")
			if billboard then billboard.Enabled = desiredVisibility end
		end
	end
end
function applyHighlight(plr)
	if plr == player then return end
	local existing = Storage:FindFirstChild(plr.Name)
	if existing then existing:Destroy() end
	local highlight = Instance.new("Highlight", Storage)
	highlight.Name = plr.Name
	highlight.FillColor = plr.Team and plr.Team.TeamColor.Color or Color3.fromRGB(255, 255, 255)
	highlight.FillTransparency = 0.5
	highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
	highlight.OutlineTransparency = 0
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.Enabled = isESPEnabled
	if plr.Character then highlight.Adornee = plr.Character end
	plr.CharacterAdded:Connect(function(char) if highlight and highlight.Parent then highlight.Adornee = char end end)
	plr.CharacterRemoving:Connect(function() if highlight and highlight.Parent then highlight.Adornee = nil end end)
	return highlight
end
function removeHighlight(plr)
	if plr then
		local existing = Storage:FindFirstChild(plr.Name)
		if existing then existing:Destroy() end
	end
end
function toggleESP(enabled)
	if isStealthMode and enabled == true then return end
	isESPEnabled = enabled
	if enabled then
		for _, plr in pairs(Players:GetPlayers()) do
			if plr ~= player then
				local h = Storage:FindFirstChild(plr.Name)
				if h then h.Enabled = true else applyHighlight(plr) end
			end
		end
	else
		for _, highlight in pairs(Storage:GetChildren()) do
			if highlight:IsA("Highlight") then highlight.Enabled = false end
		end
	end
	if GuiElements.espButton then
		local newStateText = isESPEnabled and "ESP: ON" or "ESP: OFF"
		local newTextColor = isESPEnabled and THEME.Success or THEME.Error
		GuiElements.espButton.Text = newStateText
		GuiElements.espButton:SetAttribute("CurrentTextColor", newTextColor)
		TweenService:Create(GuiElements.espButton, TextColorTweenInfo, { TextColor3 = newTextColor }):Play()
	end
end
function getShootEvent()
	local remotes = ReplicatedStorage:FindFirstChild("Remotes")
	return remotes and remotes:FindFirstChild("ShootGun")
end
function findTool()
	if character then for _, child in pairs(character:GetChildren()) do if child:IsA("Tool") then return child end end end
	if backpack then for _, child in pairs(backpack:GetChildren()) do if child:IsA("Tool") then return child end end end
	return nil
end
function isVisible(targetCharacter)
	if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end
	local startPos = character.HumanoidRootPart.Position
	local priorityParts = {"HumanoidRootPart", "LeftHand", "RightHand", "LeftFoot", "RightFoot"}
	local lastResortPart = "Head"
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {character, Storage}
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	raycastParams.IgnoreWater = true
	for _, partName in pairs(priorityParts) do
		local targetPart = targetCharacter:FindFirstChild(partName)
		if targetPart and targetPart:IsA("BasePart") then
			local targetPos = targetPart.Position
			local direction = targetPos - startPos
			local distance = direction.Magnitude
			if distance > 0.1 then
				local rayResult = workspace:Raycast(startPos, direction.Unit * distance, raycastParams)
				if rayResult and rayResult.Instance:IsDescendantOf(targetCharacter) then
					return targetPart
				end
			end
		end
	end
	local headPart = targetCharacter:FindFirstChild(lastResortPart)
	if headPart and headPart:IsA("BasePart") then
		local targetPos = headPart.Position
		local direction = targetPos - startPos
		local distance = direction.Magnitude
		if distance > 0.1 then
			local rayResult = workspace:Raycast(startPos, direction.Unit * distance, raycastParams)
			if rayResult and rayResult.Instance:IsDescendantOf(targetCharacter) then
				return headPart
			end
		end
	end
	return nil
end
function isWithinFOV(targetPart)
	if not character or not character:FindFirstChild("HumanoidRootPart") then return false end
	local cameraCFrame = Camera.CFrame
	local targetPos = targetPart.Position
	local cameraPos = cameraCFrame.Position
	if (targetPos - cameraPos).Magnitude < 0.1 then return true end
	local directionToTarget = (targetPos - cameraPos).Unit
	local cameraLook = cameraCFrame.LookVector
	local dot = math.clamp(directionToTarget:Dot(cameraLook), -1, 1)
	local angle = math.deg(math.acos(dot))
	return angle <= (targetingFOV / 2)
end
function setupToolListener(toolInstance)
	if activatedConnection then activatedConnection:Disconnect(); activatedConnection = nil end
	if currentTool and currentTool ~= toolInstance and not currentTool.Enabled then pcall(function() currentTool.Enabled = true end) end
	currentTool = toolInstance
	if toolInstance and toolInstance:IsA("Tool") then
		local cooldownActive = currentEffectiveCooldown > 0 and (tick() - lastShotTime < currentEffectiveCooldown)
		pcall(function() toolInstance.Enabled = not cooldownActive end)
		activatedConnection = toolInstance.Activated:Connect(function()
			lastShotTime = tick()
			currentEffectiveCooldown = calculateEffectiveCooldown(toolInstance)
			if toolInstance then pcall(function() toolInstance.Enabled = false end) end
		end)
	else
		currentEffectiveCooldown = 0
	end
end
function findClosestEnemy()
	local maxDistance = 400
	local closestEnemy = nil
	local closestVisiblePart = nil
	local closestDistance = maxDistance
	local playerRootPart = character and character:FindFirstChild("HumanoidRootPart")
	if not playerRootPart then return nil, nil end
	local playerRootPos = playerRootPart.Position
	local myTeam = player.Team
	if not myTeam then return nil, nil end
	for _, targetPlayer in pairs(Players:GetPlayers()) do
		if targetPlayer ~= player and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and targetPlayer.Character:FindFirstChildOfClass("Humanoid") then
			local targetChar = targetPlayer.Character
			local targetRoot = targetChar.HumanoidRootPart
			local targetHumanoid = targetChar:FindFirstChildOfClass("Humanoid")
			local targetTeam = targetPlayer.Team
			local isActualOpponent = false
			if targetTeam then
				if myTeam.Name == "Team1" and targetTeam.Name == "Team2" then isActualOpponent = true
				elseif myTeam.Name == "Team2" and targetTeam.Name == "Team1" then isActualOpponent = true
				end
			end
			if targetHumanoid.Health > 0 and not excludedPlayers[targetPlayer] and isActualOpponent then
				local distance = (playerRootPos - targetRoot.Position).Magnitude
				if distance < closestDistance then
					local visiblePart = isVisible(targetChar)
					if visiblePart and isWithinFOV(targetRoot) then
						closestDistance = distance
						closestEnemy = targetPlayer
						closestVisiblePart = visiblePart
					end
				end
			end
		end
	end
	return closestEnemy, closestVisiblePart
end
function shoot()
	if not isAutoTargetEnabled then return end
	if not character or not character.Parent then return end
	if not character:FindFirstChild("HumanoidRootPart") then return end
	local tool = currentTool
	if not tool or tool.Parent ~= character then
		tool = findTool()
		if tool and tool.Parent == character then setupToolListener(tool) else return end
	end
	local shootEvent = getShootEvent()
	if not shootEvent then return end
	local effectiveCooldown = calculateEffectiveCooldown(tool)
	local currentTime = tick()
	if currentTime - lastShotTime < effectiveCooldown then return end
	local targetEnemy, visiblePart = findClosestEnemy()
	if not visiblePart or not targetEnemy or not targetEnemy.Character then return end
	lastShotTime = currentTime
	currentEffectiveCooldown = effectiveCooldown
	local toolAtDecision = tool
	local fireSoundAtDecision = tool:FindFirstChild("Fire")
	local bulletTypeAtDecision = tool:GetAttribute("BulletType")
	local startPosAtDecision
	local muzzleAttach = tool:FindFirstChild("Muzzle", true)
	if muzzleAttach and muzzleAttach:IsA("Attachment") then
		startPosAtDecision = muzzleAttach.WorldPosition
	else
		local handle = tool:FindFirstChild("Handle")
		startPosAtDecision = (handle and handle:IsA("BasePart") and handle.Position) or character.HumanoidRootPart.Position
	end
	local visiblePartAtDecision = visiblePart
	task.spawn(function()
		if shootDelayMilliseconds > 0 then
			task.wait(shootDelayMilliseconds / 1000)
		end
		if not toolAtDecision or toolAtDecision.Parent ~= character then return end
		if not character or not character.Parent then return end
		if not targetEnemy or not targetEnemy.Parent or not targetEnemy.Character or not targetEnemy.Character.Parent then return end
		local targetHumanoid = targetEnemy.Character:FindFirstChildOfClass("Humanoid")
		local revalidatedPart = isVisible(targetEnemy.Character)
		if not revalidatedPart or not targetHumanoid or targetHumanoid.Health <= 0 or excludedPlayers[targetEnemy] then return end
		local fireArgs = {}
		local actualHitPart = revalidatedPart
		local actualImpactPoint = revalidatedPart.Position
		local endPointForVisuals = actualImpactPoint
		fireArgs = {startPosAtDecision, actualImpactPoint, actualHitPart, actualImpactPoint}
		
		local successFire, errFire = pcall(function()
			shootEvent:FireServer(unpack(fireArgs))
		end)
		if successFire then
			if fireSoundAtDecision and fireSoundAtDecision:IsA("Sound") then
				pcall(function() fireSoundAtDecision:Play() end)
			end
			if BulletRenderer_upvr and muzzleAttach and endPointForVisuals then
				pcall(BulletRenderer_upvr, startPosAtDecision, endPointForVisuals, bulletTypeAtDecision)
			end
			pcall(function() toolAtDecision:Activate() end)
			task.wait()
			if toolAtDecision and toolAtDecision.Parent == character then
				pcall(function() toolAtDecision.Enabled = false end)
			end
		end
	end)
end
function getTooltipLabel(parent)
	if TooltipLabel and TooltipLabel.Parent then return TooltipLabel end
	TooltipLabel = Instance.new("Frame", parent)
	TooltipLabel.Name = "TooltipFrame"
	TooltipLabel.Size = UDim2.new(0, 100, 0, 25)
	TooltipLabel.BackgroundColor3 = THEME.Tooltip
	TooltipLabel.BackgroundTransparency = 0.05
	TooltipLabel.BorderSizePixel = 0
	TooltipLabel.Position = UDim2.new(0, 0, 0, 0)
	TooltipLabel.ZIndex = 100
	TooltipLabel.Visible = false
	TooltipLabel.ClipsDescendants = true
	local corner = Instance.new("UICorner", TooltipLabel)
	corner.CornerRadius = UDim.new(0, 3)
	local padding = Instance.new("UIPadding", TooltipLabel)
	padding.PaddingLeft = UDim.new(0, 5)
	padding.PaddingRight = UDim.new(0, 5)
	padding.PaddingTop = UDim.new(0, 3)
	padding.PaddingBottom = UDim.new(0, 3)
	local textLabel = Instance.new("TextLabel", TooltipLabel)
	textLabel.Name = "TooltipText"
	textLabel.Size = UDim2.new(1, 0, 1, 0)
	textLabel.BackgroundTransparency = 1
	textLabel.TextColor3 = THEME.TextDisabled
	textLabel.Font = THEME.Font
	textLabel.TextSize = THEME.SmallTextSize
	textLabel.Text = "Tooltip"
	textLabel.TextXAlignment = Enum.TextXAlignment.Center
	textLabel.TextYAlignment = Enum.TextYAlignment.Center
	textLabel.ZIndex = 101
	textLabel.RichText = true
	local textConstraint = Instance.new("UITextSizeConstraint", textLabel)
	textConstraint.MaxTextSize = THEME.SmallTextSize
	local function updateSize()
		task.wait()
		if not textLabel or not textLabel.Parent then return end
		TooltipLabel.Size = UDim2.new(0, textLabel.TextBounds.X + 10, 0, textLabel.TextBounds.Y + 6)
	end
	textLabel:GetPropertyChangedSignal("Text"):Connect(updateSize)
	updateSize()
	return TooltipLabel
end
function showTooltip(guiObject, text)
	if not TooltipLabel or not TooltipLabel.Parent then return end
	local textLabel = TooltipLabel:FindFirstChild("TooltipText")
	if not textLabel then return end
	textLabel.Text = text
	local mousePos = UserInputService:GetMouseLocation()
	local guiInset = GuiService:GetGuiInset()
	local offsetX, offsetY = 15, 10
	TooltipLabel.Position = UDim2.new(0, mousePos.X + offsetX, 0, mousePos.Y - guiInset.Y + offsetY)
	task.wait()
	local viewportSize = Camera.ViewportSize
	local absSize = TooltipLabel.AbsoluteSize
	local currentPosX, currentPosY = TooltipLabel.Position.X.Offset, TooltipLabel.Position.Y.Offset
	if currentPosX + absSize.X > viewportSize.X then currentPosX = mousePos.X - absSize.X - offsetX end
	if currentPosY + absSize.Y > viewportSize.Y - guiInset.Y then currentPosY = mousePos.Y - absSize.Y - offsetY - guiInset.Y end
	TooltipLabel.Position = UDim2.new(0, currentPosX, 0, currentPosY)
	TooltipLabel.Visible = true
end
function hideTooltip()
	if TooltipLabel then TooltipLabel.Visible = false end
end
function createStyledButton(parent, initialText, initialTextColor, position, size, tooltipText)
	local button = Instance.new("TextButton", parent)
	button.Size = size
	button.Position = position
	button.BackgroundColor3 = THEME.ButtonBackground
	button.Font = THEME.Font
	button.Text = initialText
	button.TextColor3 = initialTextColor
	button.TextSize = THEME.TextSize
	button.AutoButtonColor = false
	button.ClipsDescendants = true
	local corner = Instance.new("UICorner", button)
	corner.CornerRadius = UDim.new(0, THEME.CornerRadius)
	local stroke = Instance.new("UIStroke", button)
	stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	stroke.Color = THEME.ButtonOutline
	stroke.Thickness = THEME.ButtonOutlineThickness
	stroke.Transparency = THEME.StrokeTransparency
	local uiScale = Instance.new("UIScale", button)
	uiScale.Scale = 1
	button:SetAttribute("Hovering", false)
	button:SetAttribute("Tooltip", tooltipText or "")
	button:SetAttribute("CurrentTextColor", initialTextColor)
	local hoverTweenInfo = TweenInfo.new(THEME.AnimationSpeed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local pressTweenInfo = TweenInfo.new(THEME.AnimationSpeed * 0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local scaleTweenInfo = TweenInfo.new(THEME.AnimationSpeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
	button.MouseEnter:Connect(function()
		button:SetAttribute("Hovering", true)
		TweenService:Create(stroke, hoverTweenInfo, { Color = THEME.ButtonOutlineHover }):Play()
		TweenService:Create(button, hoverTweenInfo, { BackgroundColor3 = THEME.ButtonBackgroundHover }):Play()
		TweenService:Create(uiScale, scaleTweenInfo, { Scale = THEME.ScaleFactorHover }):Play()
		if button:GetAttribute("Tooltip") ~= "" then showTooltip(button, button:GetAttribute("Tooltip")) end
	end)
	button.MouseLeave:Connect(function()
		button:SetAttribute("Hovering", false)
		TweenService:Create(stroke, hoverTweenInfo, { Color = THEME.ButtonOutline }):Play()
		TweenService:Create(button, hoverTweenInfo, { BackgroundColor3 = THEME.ButtonBackground }):Play()
		TweenService:Create(uiScale, scaleTweenInfo, { Scale = 1 }):Play()
		hideTooltip()
	end)
	button.MouseButton1Down:Connect(function()
		TweenService:Create(uiScale, pressTweenInfo, { Scale = THEME.ScaleFactorPress }):Play()
		hideTooltip()
	end)
	button.MouseButton1Up:Connect(function()
		local targetScale = button:GetAttribute("Hovering") and THEME.ScaleFactorHover or 1
		local targetBgColor = button:GetAttribute("Hovering") and THEME.ButtonBackgroundHover or THEME.ButtonBackground
		local targetOutlineColor = button:GetAttribute("Hovering") and THEME.ButtonOutlineHover or THEME.ButtonOutline
		TweenService:Create(uiScale, scaleTweenInfo, { Scale = targetScale }):Play()
		TweenService:Create(button, hoverTweenInfo, { BackgroundColor3 = targetBgColor }):Play()
		TweenService:Create(stroke, hoverTweenInfo, { Color = targetOutlineColor }):Play()
		if button:GetAttribute("Hovering") and button:GetAttribute("Tooltip") ~= "" then showTooltip(button, button:GetAttribute("Tooltip")) end
	end)
	return button
end
function updateSliderStyle(sliderContainer, value, isEnabled)
	if not sliderContainer or not sliderContainer:IsA("Frame") then return end
	local valueLabel = sliderContainer:FindFirstChild("ValueLabel")
	local sliderTrack = sliderContainer:FindFirstChild("SliderTrack")
	if not valueLabel or not sliderTrack then return end
	local sliderFill = sliderTrack:FindFirstChild("SliderFill")
	local sliderThumb = sliderTrack:FindFirstChild("SliderThumb")
	if not sliderFill or not sliderThumb then return end
	local minValue = sliderContainer:GetAttribute("MinValue") or 0
	local maxValue = sliderContainer:GetAttribute("MaxValue") or 100
	local range = maxValue - minValue
	if range <= 0 then range = 1 end
	local percentage = math.clamp((value - minValue) / range, 0, 1)
	sliderThumb.Position = UDim2.new(percentage, 0, 0.5, 0)
	sliderFill.Size = UDim2.new(percentage, 0, 1, 0)
	valueLabel.Text = tostring(math.floor(value))
	local thumbColor = isEnabled and THEME.AccentAlt or THEME.Tertiary
	local fillColor = isEnabled and THEME.Accent or THEME.Tertiary
	local valueColor = isEnabled and THEME.Text or THEME.TextDisabled
	local trackColor = isEnabled and THEME.SliderTrack or THEME.SliderTrackDisabled
	local thumbBorderColor = isEnabled and THEME.SliderThumbBorder or THEME.SliderThumbBorderDisabled
	sliderThumb.BackgroundColor3 = thumbColor
	sliderFill.BackgroundColor3 = fillColor
	valueLabel.TextColor3 = valueColor
	sliderTrack.BackgroundColor3 = trackColor
	sliderThumb.BorderColor3 = thumbBorderColor
end
function setSliderEnabled(sliderContainer, enabled)
	if not sliderContainer or not sliderContainer:IsA("Frame") then return end
	sliderContainer:SetAttribute("Enabled", enabled)
	local valueLabel = sliderContainer:FindFirstChild("ValueLabel")
	local currentVal = tonumber(valueLabel and valueLabel.Text or sliderContainer:GetAttribute("InitialValue") or 0)
	updateSliderStyle(sliderContainer, currentVal, enabled)
end
function setSliderValue(sliderContainer, value)
	if not sliderContainer or not sliderContainer:IsA("Frame") then return end
	local minValue = sliderContainer:GetAttribute("MinValue") or 0
	local maxValue = sliderContainer:GetAttribute("MaxValue") or 100
	local clampedValue = math.clamp(value, minValue, maxValue)
	local isEnabled = sliderContainer:GetAttribute("Enabled")
	updateSliderStyle(sliderContainer, clampedValue, isEnabled)
end
function createSlider(parent, labelText, minValue, maxValue, initialValue, valueChangedCallback, tooltipText)
	local container = Instance.new("Frame", parent)
	container.Size = UDim2.new(1, 0, 0, THEME.ElementHeight * 1.5)
	container.BackgroundTransparency = 1
	container:SetAttribute("Tooltip", tooltipText or "")
	container:SetAttribute("Enabled", true)
	container:SetAttribute("MinValue", minValue)
	container:SetAttribute("MaxValue", maxValue)
	container:SetAttribute("InitialValue", initialValue)
	local label = Instance.new("TextLabel", container)
	label.Size = UDim2.new(0.7, 0, 0, THEME.SmallElementHeight)
	label.Position = UDim2.new(0, 0, 0, 0)
	label.BackgroundTransparency = 1
	label.TextColor3 = THEME.TextDisabled
	label.Font = THEME.Font
	label.TextSize = THEME.SmallTextSize
	label.Text = labelText
	label.TextXAlignment = Enum.TextXAlignment.Left
	local valueLabel = Instance.new("TextLabel", container)
	valueLabel.Name = "ValueLabel"
	valueLabel.Size = UDim2.new(0.3, 0, 0, THEME.SmallElementHeight)
	valueLabel.Position = UDim2.new(0.7, 0, 0, 0)
	valueLabel.BackgroundTransparency = 1
	valueLabel.TextColor3 = THEME.Text
	valueLabel.Font = THEME.Font
	valueLabel.TextSize = THEME.SmallTextSize
	valueLabel.Text = tostring(math.floor(initialValue))
	valueLabel.TextXAlignment = Enum.TextXAlignment.Right
	local sliderTrack = Instance.new("Frame", container)
	sliderTrack.Name = "SliderTrack"
	sliderTrack.Size = UDim2.new(1, 0, 0, THEME.SliderHeight + 6)
	sliderTrack.Position = UDim2.new(0, 0, 1, -(THEME.SliderHeight + 6) - 4)
	sliderTrack.BackgroundColor3 = THEME.SliderTrack
	local trackCorner = Instance.new("UICorner", sliderTrack)
	trackCorner.CornerRadius = UDim.new(0, (THEME.SliderHeight + 6) / 2)
	local trackStroke = Instance.new("UIStroke", sliderTrack)
	trackStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	trackStroke.Color = THEME.Tertiary
	trackStroke.Thickness = 1
	trackStroke.Transparency = 0.7
	local sliderFill = Instance.new("Frame", sliderTrack)
	sliderFill.Name = "SliderFill"
	sliderFill.Size = UDim2.new(0,0,1,0)
	sliderFill.BackgroundColor3 = THEME.Accent
	sliderFill.BorderSizePixel = 0
	local fillCorner = Instance.new("UICorner", sliderFill)
	fillCorner.CornerRadius = UDim.new(0, (THEME.SliderHeight + 6) / 2)
	local sliderThumb = Instance.new("Frame", sliderTrack)
	sliderThumb.Name = "SliderThumb"
	local thumbActualSize = THEME.SliderThumbSize
	sliderThumb.Size = UDim2.fromOffset(thumbActualSize, thumbActualSize)
	sliderThumb.AnchorPoint = Vector2.new(0.5, 0.5)
	sliderThumb.Position = UDim2.new(0, 0, 0.5, 0)
	sliderThumb.BackgroundColor3 = THEME.AccentAlt
	sliderThumb.BorderSizePixel = 2
	sliderThumb.BorderColor3 = THEME.SliderThumbBorder
	local thumbCorner = Instance.new("UICorner", sliderThumb)
	thumbCorner.CornerRadius = UDim.new(0.5, 0)
	local thumbScale = Instance.new("UIScale", sliderThumb)
	thumbScale.Scale = 1
	local dragging = false
	local inputChangedConn = nil
	local inputEndedConn = nil
	local thumbTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
	local function updateSlider(inputPos)
		if not container:GetAttribute("Enabled") then return end
		local relativePos = sliderTrack.AbsolutePosition
		local trackSize = sliderTrack.AbsoluteSize
		if trackSize.X <= 0 then return end
		local thumbRadius = sliderThumb.AbsoluteSize.X / 2
		local usableWidth = trackSize.X - (thumbRadius * 2)
		if usableWidth <=0 then usableWidth = 1 end
		local rawX = inputPos.X - relativePos.X - thumbRadius
		local percentage = math.clamp(rawX / usableWidth, 0, 1)
		local value = minValue + (maxValue - minValue) * percentage
		local newValue = math.floor(value)
		updateSliderStyle(container, newValue, true)
		if valueChangedCallback then valueChangedCallback(newValue) end
	end
	updateSliderStyle(container, initialValue, true)
	local function onInputBegan(input)
		if not container:GetAttribute("Enabled") then return end
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			TweenService:Create(thumbScale, thumbTweenInfo, {Scale = 1.1}):Play()
			updateSlider(input.Position)
			hideTooltip()
			if inputChangedConn then inputChangedConn:Disconnect() end
			if inputEndedConn then inputEndedConn:Disconnect() end
			inputEndedConn = input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
					TweenService:Create(thumbScale, thumbTweenInfo, {Scale = 1}):Play()
					if inputChangedConn then inputChangedConn:Disconnect(); inputChangedConn = nil end
					if inputEndedConn then inputEndedConn:Disconnect(); inputEndedConn = nil end
				end
			end)
			inputChangedConn = RunService.RenderStepped:Connect(function()
				if dragging then
					updateSlider(UserInputService:GetMouseLocation())
				else
					if inputChangedConn then inputChangedConn:Disconnect(); inputChangedConn = nil end
				end
			end)
		end
	end
	sliderTrack.InputBegan:Connect(onInputBegan)
	sliderThumb.InputBegan:Connect(onInputBegan)
	container.MouseEnter:Connect(function()
		if container:GetAttribute("Tooltip") ~= "" and not dragging then
			showTooltip(container, container:GetAttribute("Tooltip"))
		end
	end)
	container.MouseLeave:Connect(function()
		if not dragging then hideTooltip() end
	end)
	return container, valueLabel
end
local function toggleStealthMode()
	isStealthMode = not isStealthMode
	local targetTooltip = isStealthMode and "Switch to Normal Mode" or "Switch to Stealth Mode"
	local targetStrokeColor = isStealthMode and THEME.Error or THEME.Accent
	local targetCoreColor = isStealthMode and THEME.Error or THEME.Accent
	local stealthBtnClickArea = GuiElements.stealthModeClickButton
	local stealthBtnContainer = GuiElements.stealthModeStroke and GuiElements.stealthModeStroke.Parent
	if stealthBtnClickArea then stealthBtnClickArea:SetAttribute("Tooltip", targetTooltip) end
	if GuiElements.stealthModeStroke then TweenService:Create(GuiElements.stealthModeStroke, DimTweenInfo, { Color = targetStrokeColor }):Play() end
	if GuiElements.stealthModeCore then TweenService:Create(GuiElements.stealthModeCore, DimTweenInfo, { BackgroundColor3 = targetCoreColor }):Play() end
	if stealthBtnContainer then
		local pulseScale = stealthBtnContainer:FindFirstChildWhichIsA("UIScale") or Instance.new("UIScale", stealthBtnContainer)
		local pressTweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local releaseTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		local s1 = TweenService:Create(pulseScale, pressTweenInfo, {Scale = 0.9})
		local s2 = TweenService:Create(pulseScale, releaseTweenInfo, {Scale = 1})
		s1.Completed:Connect(function() s2:Play() end)
		s1:Play()
	end
	local targetBgTrans = isStealthMode and 0.5 or 0
	local targetTextTrans = isStealthMode and 0.3 or 0
	local buttonsToFade = {GuiElements.fovChangerButton, GuiElements.resetFovButton, GuiElements.espButton}
	for _, button in ipairs(buttonsToFade) do
		if button then
			TweenService:Create(button, DimTweenInfo, {BackgroundTransparency = targetBgTrans}):Play()
			TweenService:Create(button, DimTweenInfo, {TextTransparency = targetTextTrans}):Play()
		end
	end
	if isStealthMode then
		isFOVChangerEnabled = false
		Camera.FieldOfView = gameDefaultFOV
		if GuiElements.fovChangerButton then
			GuiElements.fovChangerButton.Text = "FOV: OFF"
			GuiElements.fovChangerButton.TextColor3 = THEME.Error
			GuiElements.fovChangerButton:SetAttribute("CurrentTextColor", THEME.Error)
		end
		if GuiElements.camFovSliderContainer then
			setSliderEnabled(GuiElements.camFovSliderContainer, false)
			setSliderValue(GuiElements.camFovSliderContainer, gameDefaultFOV)
		end
		if isESPEnabled then toggleESP(false) end
	else
		if GuiElements.fovChangerButton then
			local initialFovTextColor = isFOVChangerEnabled and THEME.Success or THEME.Error
			GuiElements.fovChangerButton.TextColor3 = initialFovTextColor
			GuiElements.fovChangerButton:SetAttribute("CurrentTextColor", initialFovTextColor)
			GuiElements.fovChangerButton.Text = isFOVChangerEnabled and "FOV: ON" or "FOV: OFF"
		end
		if GuiElements.camFovSliderContainer then
			setSliderEnabled(GuiElements.camFovSliderContainer, isFOVChangerEnabled)
			setSliderValue(GuiElements.camFovSliderContainer, isFOVChangerEnabled and currentCameraFOV or gameDefaultFOV)
		end
		if GuiElements.espButton then
			local initialEspTextColor = isESPEnabled and THEME.Success or THEME.Error
			GuiElements.espButton.TextColor3 = initialEspTextColor
			GuiElements.espButton:SetAttribute("CurrentTextColor", initialEspTextColor)
			GuiElements.espButton.Text = isESPEnabled and "ESP: ON" or "ESP: OFF"
		end
	end
	updateFOVCircle()
	updateAllExcludedLabelsVisibility()
end
function createBeautifulGUI()
	local oldGui = playerGui:FindFirstChild("TheMistGUI_DelaySwitcher_V24")
	if oldGui then oldGui:Destroy() end
	local gui = Instance.new("ScreenGui", playerGui)
	gui.Name = "TheMistGUI_DelaySwitcher_V24"
	gui.ResetOnSpawn = false
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	gui.DisplayOrder = 999
	gui.IgnoreGuiInset = true
	local uiScale = Instance.new("UIScale", gui)
	local BASE_SIZE = Vector2.new(GUI_BASE_WIDTH, GUI_BASE_HEIGHT)
	local SCALE_RATIO = 0.65
	local scaleConnection
	local function updateScale()
		local viewport = Camera.ViewportSize
		if viewport.X == 0 or viewport.Y == 0 then return end
		local shortestSide = math.min(viewport.X, viewport.Y)
		local scaleFactor = (shortestSide * SCALE_RATIO) / BASE_SIZE.Y
		uiScale.Scale = scaleFactor
	end
	updateScale()
	scaleConnection = RunService.RenderStepped:Connect(updateScale)
	mainFrame = Instance.new("Frame", gui)
	mainFrame.Visible = false
	mainFrame.AnchorPoint = Vector2.new(1, 0.5)
	mainFrame.Size = UDim2.fromScale(0, 0)
	mainFrame.AutomaticSize = Enum.AutomaticSize.Y
	mainFrame.BackgroundColor3 = THEME.Background
	mainFrame.BackgroundTransparency = 0
	mainFrame.BorderSizePixel = 0
	mainFrame.ClipsDescendants = true
	mainFrame.ZIndex = 5
	mainFrame.Active = true
	mainFrame.Draggable = false
	local frameCorner = Instance.new("UICorner", mainFrame)
	frameCorner.CornerRadius = UDim.new(0, THEME.CornerRadius)
	local sizeConstraint = Instance.new("UISizeConstraint", mainFrame)
	sizeConstraint.MinSize = Vector2.new(THEME.PanelMinWidth * GUI_SIZE_MULTIPLIER, 210 * GUI_SIZE_MULTIPLIER)
	sizeConstraint.MaxSize = Vector2.new(THEME.PanelMaxWidth * GUI_SIZE_MULTIPLIER, math.huge)
	local bgGradient = Instance.new("UIGradient", mainFrame)
	bgGradient.Rotation = 135
	bgGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, THEME.BackgroundSlightlyLighter),
		ColorSequenceKeypoint.new(0.3, THEME.Background),
		ColorSequenceKeypoint.new(0.5, THEME.Primary),
		ColorSequenceKeypoint.new(0.8, THEME.BackgroundSubtleVariant),
		ColorSequenceKeypoint.new(1, THEME.BackgroundSlightlyLighter),
	})
	bgGradient.Offset = Vector2.new(-1, -1)
	local padding = Instance.new("UIPadding", mainFrame)
	padding.PaddingTop = UDim.new(0, THEME.Padding)
	padding.PaddingBottom = UDim.new(0, THEME.Padding)
	padding.PaddingLeft = UDim.new(0, THEME.Padding)
	padding.PaddingRight = UDim.new(0, THEME.Padding)
	local listLayout = Instance.new("UIListLayout", mainFrame)
	listLayout.Padding = UDim.new(0, THEME.Padding)
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	listLayout.FillDirection = Enum.FillDirection.Vertical
	getTooltipLabel(gui)
	local titleFrame = Instance.new("Frame", mainFrame)
	titleFrame.Size = UDim2.new(1, 0, 0, THEME.TitleSize + 2)
	titleFrame.BackgroundTransparency = 1
	titleFrame.LayoutOrder = 0
	local titleLabel = Instance.new("TextLabel", titleFrame)
	titleLabel.Size = UDim2.new(1, -25, 1, 0)
	titleLabel.Position = UDim2.fromOffset(0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "THE MIST"
	titleLabel.TextColor3 = THEME.Accent
	titleLabel.Font = THEME.FontTitle
	titleLabel.TextSize = THEME.TitleSize
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	local subtitleLabel = Instance.new("TextLabel", mainFrame)
	subtitleLabel.Size = UDim2.new(1, -THEME.Padding*2, 0, THEME.SubtitleSize + 2)
	subtitleLabel.Position = UDim2.fromOffset(THEME.Padding, 0)
	subtitleLabel.BackgroundTransparency = 1
	subtitleLabel.Text = "triggerbot-module v3.2"
	subtitleLabel.TextColor3 = THEME.TextDisabled
	subtitleLabel.Font = THEME.Font
	subtitleLabel.TextSize = THEME.SubtitleSize
	subtitleLabel.LayoutOrder = 1
	subtitleLabel.TextXAlignment = Enum.TextXAlignment.Left
	local stealthContainer = Instance.new("Frame", titleFrame)
	stealthContainer.Name = "StealthModeContainer"
	stealthContainer.Size = UDim2.fromOffset(18, 18)
	stealthContainer.AnchorPoint = Vector2.new(1, 0.5)
	stealthContainer.Position = UDim2.new(1, -THEME.Padding, 0.5, 0)
	stealthContainer.BackgroundColor3 = THEME.Primary
	stealthContainer.BackgroundTransparency = 0.3
	local scCorner = Instance.new("UICorner", stealthContainer)
	scCorner.CornerRadius = UDim.new(0, 4)
	local scStroke = Instance.new("UIStroke", stealthContainer)
	scStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	scStroke.Color = isStealthMode and THEME.Error or THEME.Accent
	scStroke.Thickness = 1.5
	scStroke.Transparency = 0.2
	GuiElements.stealthModeStroke = scStroke
	local scCore = Instance.new("Frame", stealthContainer)
	scCore.Name = "Core"
	scCore.Size = UDim2.fromScale(0.5, 0.5)
	scCore.AnchorPoint = Vector2.new(0.5, 0.5)
	scCore.Position = UDim2.fromScale(0.5, 0.5)
	scCore.BackgroundColor3 = isStealthMode and THEME.Error or THEME.Accent
	scCore.BackgroundTransparency = 0.1
	local scCoreCorner = Instance.new("UICorner", scCore)
	scCoreCorner.CornerRadius = UDim.new(0.5, 0)
	GuiElements.stealthModeCore = scCore
	local stealthClickButton = Instance.new("TextButton", stealthContainer)
	stealthClickButton.Name = "StealthClickArea"
	stealthClickButton.Size = UDim2.fromScale(1, 1)
	stealthClickButton.BackgroundTransparency = 1
	stealthClickButton.Text = ""
	stealthClickButton.ZIndex = 2
	stealthClickButton:SetAttribute("Tooltip", isStealthMode and "Switch to Normal Mode" or "Switch to Stealth Mode")
	GuiElements.stealthModeClickButton = stealthClickButton
	local scScale = Instance.new("UIScale", stealthContainer)
	scScale.Scale = 1
	local hoverTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	stealthClickButton.MouseEnter:Connect(function()
		TweenService:Create(scScale, hoverTweenInfo, {Scale = 1.1}):Play()
		local currentStrokeColor = isStealthMode and THEME.Error or THEME.Accent
		TweenService:Create(scStroke, hoverTweenInfo, {Color = currentStrokeColor:Lerp(Color3.new(1,1,1), 0.3), Transparency = 0}):Play()
		if stealthClickButton:GetAttribute("Tooltip") ~= "" then showTooltip(stealthClickButton, stealthClickButton:GetAttribute("Tooltip")) end
	end)
	stealthClickButton.MouseLeave:Connect(function()
		TweenService:Create(scScale, hoverTweenInfo, {Scale = 1}):Play()
		local currentStrokeColor = isStealthMode and THEME.Error or THEME.Accent
		TweenService:Create(scStroke, hoverTweenInfo, {Color = currentStrokeColor, Transparency = 0.2}):Play()
		hideTooltip()
	end)
	stealthClickButton.MouseButton1Click:Connect(toggleStealthMode)
	local mainControlsFrame = Instance.new("Frame", mainFrame)
	mainControlsFrame.Size = UDim2.new(1, 0, 0, THEME.ElementHeight * 2 + THEME.Padding)
	mainControlsFrame.BackgroundTransparency = 1
	mainControlsFrame.LayoutOrder = 2
	local mainControlsLayout = Instance.new("UIListLayout", mainControlsFrame)
	mainControlsLayout.Padding = UDim.new(0, THEME.Padding)
	mainControlsLayout.SortOrder = Enum.SortOrder.LayoutOrder
	mainControlsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	local initialAutoTargetTextColor = isAutoTargetEnabled and THEME.Success or THEME.Error
	local initialEspTextColor = isESPEnabled and THEME.Success or THEME.Error
	GuiElements.autoTargetButton = createStyledButton(mainControlsFrame, "TARGET: OFF", initialAutoTargetTextColor, UDim2.new(), UDim2.new(1,0,0,THEME.ElementHeight), "Toggle Auto Targeting")
	GuiElements.espButton = createStyledButton(mainControlsFrame, "ESP: ON", initialEspTextColor, UDim2.new(), UDim2.new(1,0,0,THEME.ElementHeight), "Toggle Player ESP")
	GuiElements.autoTargetButton.Text = isAutoTargetEnabled and "TARGET: ON" or "TARGET: OFF"
	GuiElements.espButton.Text = isESPEnabled and "ESP: ON" or "ESP: OFF"
	GuiElements.espButton.BackgroundTransparency = isStealthMode and 0.5 or 0
	GuiElements.espButton.TextTransparency = isStealthMode and 0.3 or 0
	local settingsFrame = Instance.new("Frame", mainFrame)
	settingsFrame.Size = UDim2.new(1, 0, 0, 0)
	settingsFrame.AutomaticSize = Enum.AutomaticSize.Y
	settingsFrame.BackgroundTransparency = 1
	settingsFrame.LayoutOrder = 4
	local settingsLayout = Instance.new("UIListLayout", settingsFrame)
	settingsLayout.Padding = UDim.new(0, THEME.Padding + 2)
	settingsLayout.SortOrder = Enum.SortOrder.LayoutOrder
	settingsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	settingsLayout.FillDirection = Enum.FillDirection.Vertical
	local targetFovSliderContainer, targetFovValueLabel = createSlider(settingsFrame, "Target FOV", 0, 180, targetingFOV, function(value) targetingFOV = value; updateFOVCircle() end, "Aim assist Field of View (degrees)")
	GuiElements.targetFovSliderContainer = targetFovSliderContainer
	GuiElements.targetFovValueLabel = targetFovValueLabel
	targetFovSliderContainer.LayoutOrder = 1
	local delayModeSwitcherFrame = Instance.new("TextButton", settingsFrame)
	delayModeSwitcherFrame.Name = "DelayModeSwitcherFrame"
	delayModeSwitcherFrame.Size = UDim2.new(1, 0, 0, THEME.ElementHeight)
	delayModeSwitcherFrame.BackgroundTransparency = 1
	delayModeSwitcherFrame.Text = ""
	delayModeSwitcherFrame.AutoButtonColor = false
	delayModeSwitcherFrame.LayoutOrder = 2
	delayModeSwitcherFrame:SetAttribute("Tooltip", "Click to switch delay mode")
	local switchTrack = Instance.new("Frame", delayModeSwitcherFrame)
	switchTrack.Name = "Track"
	switchTrack.Size = UDim2.new(1, -20, 1, -4)
	switchTrack.AnchorPoint = Vector2.new(0.5, 0.5)
	switchTrack.Position = UDim2.fromScale(0.5, 0.5)
	switchTrack.BackgroundColor3 = THEME.PrimaryLighter
	switchTrack.BackgroundTransparency = 0.5
	local trackCorner = Instance.new("UICorner", switchTrack)
	trackCorner.CornerRadius = UDim.new(0, THEME.CornerRadius)
	local trackStroke = Instance.new("UIStroke", switchTrack)
	trackStroke.Color = THEME.Secondary
	trackStroke.Transparency = 0.6
	trackStroke.Thickness = 1
	local switchThumb = Instance.new("Frame", switchTrack)
	switchThumb.Name = "Thumb"
	switchThumb.Size = UDim2.new(0.5, -2, 1, -4)
	switchThumb.Position = UDim2.fromScale(0, 0.5)
	switchThumb.AnchorPoint = Vector2.new(0, 0.5)
	switchThumb.BackgroundColor3 = THEME.Accent
	switchThumb.BorderSizePixel = 0
	local thumbCorner = Instance.new("UICorner", switchThumb)
	thumbCorner.CornerRadius = UDim.new(0, THEME.CornerRadius - 2)
	GuiElements.delaySwitcherThumb = switchThumb
	local labelBlatant = Instance.new("TextLabel", switchTrack)
	labelBlatant.Name = "LabelBlatant"
	labelBlatant.Size = UDim2.new(0.5, 0, 1, 0)
	labelBlatant.Position = UDim2.fromScale(0, 0.5)
	labelBlatant.AnchorPoint = Vector2.new(0, 0.5)
	labelBlatant.BackgroundTransparency = 1
	labelBlatant.Font = THEME.Font
	labelBlatant.Text = "Blatant"
	labelBlatant.TextSize = THEME.SmallTextSize
	labelBlatant.TextColor3 = THEME.TextDisabled
	labelBlatant.TextXAlignment = Enum.TextXAlignment.Center
	GuiElements.delayLabelBlatant = labelBlatant
	local labelNormal = Instance.new("TextLabel", switchTrack)
	labelNormal.Name = "LabelNormal"
	labelNormal.Size = UDim2.new(0.5, 0, 1, 0)
	labelNormal.Position = UDim2.fromScale(0.5, 0.5)
	labelNormal.AnchorPoint = Vector2.new(0, 0.5)
	labelNormal.BackgroundTransparency = 1
	labelNormal.Font = THEME.Font
	labelNormal.Text = "Normal"
	labelNormal.TextSize = THEME.SmallTextSize
	labelNormal.TextColor3 = THEME.Text
	labelNormal.TextXAlignment = Enum.TextXAlignment.Center
	GuiElements.delayLabelNormal = labelNormal
	local function updateSwitcherVisuals(newMode, skipAnim)
		local targetThumbPos = (newMode == "Blatant") and UDim2.fromScale(0, 0.5) or UDim2.fromScale(0.5, 0.5)
		local blatantColor = (newMode == "Blatant") and THEME.TextActive or THEME.TextDisabled
		local normalColor = (newMode == "Normal") and THEME.TextActive or THEME.TextDisabled
		if skipAnim then
			switchThumb.Position = targetThumbPos
			labelBlatant.TextColor3 = blatantColor
			labelNormal.TextColor3 = normalColor
		else
			TweenService:Create(switchThumb, SwitchAnimationInfo, { Position = targetThumbPos }):Play()
			TweenService:Create(labelBlatant, TextColorTweenInfo, { TextColor3 = blatantColor }):Play()
			TweenService:Create(labelNormal, TextColorTweenInfo, { TextColor3 = normalColor }):Play()
		end
	end
	delayModeSwitcherFrame.MouseButton1Click:Connect(function()
		hideTooltip()
		if currentDelayMode == "Normal" then
			currentDelayMode = "Blatant"
			shootDelayMilliseconds = 0
			updateSwitcherVisuals("Blatant")
		else
			currentDelayMode = "Normal"
			shootDelayMilliseconds = 180
			updateSwitcherVisuals("Normal")
		end
	end)
	delayModeSwitcherFrame.MouseEnter:Connect(function()
		if delayModeSwitcherFrame:GetAttribute("Tooltip") ~= "" then
			showTooltip(delayModeSwitcherFrame, delayModeSwitcherFrame:GetAttribute("Tooltip"))
		end
	end)
	delayModeSwitcherFrame.MouseLeave:Connect(hideTooltip)
	updateSwitcherVisuals(currentDelayMode, true)
	local excludeMethodSwitcherTitle = Instance.new("TextLabel", settingsFrame)
	excludeMethodSwitcherTitle.Size = UDim2.new(1, -THEME.Padding*2, 0, THEME.SmallTextSize)
	excludeMethodSwitcherTitle.BackgroundTransparency = 1
	excludeMethodSwitcherTitle.Font = THEME.Font
	excludeMethodSwitcherTitle.Text = "EXCLUDE BY"
	excludeMethodSwitcherTitle.TextColor3 = THEME.TextDisabled
	excludeMethodSwitcherTitle.TextSize = THEME.SmallTextSize
	excludeMethodSwitcherTitle.TextXAlignment = Enum.TextXAlignment.Center
	excludeMethodSwitcherTitle.LayoutOrder = 3

	local excludeMethodSwitcherFrame = Instance.new("TextButton", settingsFrame)
	excludeMethodSwitcherFrame.Name = "ExcludeMethodSwitcherFrame"
	excludeMethodSwitcherFrame.Size = UDim2.new(1, 0, 0, THEME.ElementHeight)
	excludeMethodSwitcherFrame.BackgroundTransparency = 1
	excludeMethodSwitcherFrame.Text = ""
	excludeMethodSwitcherFrame.AutoButtonColor = false
	excludeMethodSwitcherFrame.LayoutOrder = 4
	excludeMethodSwitcherFrame:SetAttribute("Tooltip", "Click to switch exclusion method")

	local exSwitchTrack = Instance.new("Frame", excludeMethodSwitcherFrame)
	exSwitchTrack.Name = "Track"
	exSwitchTrack.Size = UDim2.new(1, -20, 1, -4)
	exSwitchTrack.AnchorPoint = Vector2.new(0.5, 0.5)
	exSwitchTrack.Position = UDim2.fromScale(0.5, 0.5)
	exSwitchTrack.BackgroundColor3 = THEME.PrimaryLighter
	exSwitchTrack.BackgroundTransparency = 0.5
	local exTrackCorner = Instance.new("UICorner", exSwitchTrack)
	exTrackCorner.CornerRadius = UDim.new(0, THEME.CornerRadius)
	local exTrackStroke = Instance.new("UIStroke", exSwitchTrack)
	exTrackStroke.Color = THEME.Secondary
	exTrackStroke.Transparency = 0.6
	exTrackStroke.Thickness = 1

	local exSwitchThumb = Instance.new("Frame", exSwitchTrack)
	exSwitchThumb.Name = "Thumb"
	exSwitchThumb.Size = UDim2.new(0.5, -2, 1, -4)
	exSwitchThumb.Position = UDim2.fromScale(0, 0.5)
	exSwitchThumb.AnchorPoint = Vector2.new(0, 0.5)
	exSwitchThumb.BackgroundColor3 = THEME.AccentDarkRed
	exSwitchThumb.BorderSizePixel = 0
	local exThumbCorner = Instance.new("UICorner", exSwitchThumb)
	exThumbCorner.CornerRadius = UDim.new(0, THEME.CornerRadius - 2)
	
	local exLabelList = Instance.new("TextLabel", exSwitchTrack)
	exLabelList.Name = "LabelPlayerList"
	exLabelList.Size = UDim2.new(0.5, 0, 1, 0)
	exLabelList.Position = UDim2.fromScale(0, 0.5)
	exLabelList.AnchorPoint = Vector2.new(0, 0.5)
	exLabelList.BackgroundTransparency = 1
	exLabelList.Font = THEME.Font
	exLabelList.Text = "Player List"
	exLabelList.TextSize = THEME.SmallTextSize
	exLabelList.TextColor3 = THEME.TextActive
	exLabelList.TextXAlignment = Enum.TextXAlignment.Center
	
	local exLabelTouch = Instance.new("TextLabel", exSwitchTrack)
	exLabelTouch.Name = "LabelTouch"
	exLabelTouch.Size = UDim2.new(0.5, 0, 1, 0)
	exLabelTouch.Position = UDim2.fromScale(0.5, 0.5)
	exLabelTouch.AnchorPoint = Vector2.new(0, 0.5)
	exLabelTouch.BackgroundTransparency = 1
	exLabelTouch.Font = THEME.Font
	exLabelTouch.Text = "Touch"
	exLabelTouch.TextSize = THEME.SmallTextSize
	exLabelTouch.TextColor3 = THEME.TextDisabled
	exLabelTouch.TextXAlignment = Enum.TextXAlignment.Center

	local function updateExcludeSwitcherVisuals(newMethod, skipAnim)
		local targetThumbPos, thumbColor, listColor, touchColor
		if newMethod == "Player List" then
			targetThumbPos = UDim2.fromScale(0, 0.5)
			thumbColor = THEME.AccentDarkRed
			listColor = THEME.TextActive
			touchColor = THEME.TextDisabled
		else
			targetThumbPos = UDim2.fromScale(0.5, 0.5)
			thumbColor = THEME.Success
			listColor = THEME.TextDisabled
			touchColor = THEME.TextActive
		end

		if skipAnim then
			exSwitchThumb.Position = targetThumbPos
			exSwitchThumb.BackgroundColor3 = thumbColor
			exLabelList.TextColor3 = listColor
			exLabelTouch.TextColor3 = touchColor
		else
			TweenService:Create(exSwitchThumb, SwitchAnimationInfo, { Position = targetThumbPos, BackgroundColor3 = thumbColor }):Play()
			TweenService:Create(exLabelList, TextColorTweenInfo, { TextColor3 = listColor }):Play()
			TweenService:Create(exLabelTouch, TextColorTweenInfo, { TextColor3 = touchColor }):Play()
		end
	end

	excludeMethodSwitcherFrame.MouseButton1Click:Connect(function()
		hideTooltip()
		if excludeMethod == "Player List" then
			excludeMethod = "Touch"
		else
			excludeMethod = "Player List"
		end
		updateExcludeSwitcherVisuals(excludeMethod)
	end)
	excludeMethodSwitcherFrame.MouseEnter:Connect(function()
		if excludeMethodSwitcherFrame:GetAttribute("Tooltip") ~= "" then
			showTooltip(excludeMethodSwitcherFrame, excludeMethodSwitcherFrame:GetAttribute("Tooltip"))
		end
	end)
	excludeMethodSwitcherFrame.MouseLeave:Connect(hideTooltip)
	updateExcludeSwitcherVisuals(excludeMethod, true)
	local camFovSliderContainer, camFovValueLabel = createSlider(settingsFrame, "Camera FOV", 30, 120, currentCameraFOV, function(value) if isFOVChangerEnabled then currentCameraFOV = value; Camera.FieldOfView = value; updateFOVCircle() end end, "Camera Field of View (degrees)")
	GuiElements.camFovSliderContainer = camFovSliderContainer
	GuiElements.camFovValueLabel = camFovValueLabel
	camFovSliderContainer.LayoutOrder = 5
	local fovControlFrame = Instance.new("Frame", settingsFrame)
	fovControlFrame.Size = UDim2.new(1, 0, 0, THEME.SmallElementHeight * 2 + THEME.Padding)
	fovControlFrame.BackgroundTransparency = 1
	fovControlFrame.LayoutOrder = 6
	local fovControlLayout = Instance.new("UIListLayout", fovControlFrame)
	fovControlLayout.Padding = UDim.new(0, THEME.Padding)
	fovControlLayout.SortOrder = Enum.SortOrder.LayoutOrder
	fovControlLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	local initialFovTextColor = isFOVChangerEnabled and THEME.Success or THEME.Error
	GuiElements.fovChangerButton = createStyledButton(fovControlFrame, "FOV: ON", initialFovTextColor, UDim2.new(), UDim2.new(1,0,0,THEME.SmallElementHeight), "Toggle Camera FOV Changer")
	GuiElements.resetFovButton = createStyledButton(fovControlFrame, "RESET", THEME.ButtonText, UDim2.new(), UDim2.new(1,0,0,THEME.SmallElementHeight), "Reset Camera FOV to Game Default ("..tostring(math.floor(gameDefaultFOV))..")")
	GuiElements.fovChangerButton.TextSize = THEME.SmallTextSize
	GuiElements.resetFovButton.TextSize = THEME.SmallTextSize
	GuiElements.fovChangerButton.Text = isFOVChangerEnabled and "FOV: ON" or "FOV: OFF"
	GuiElements.fovChangerButton.BackgroundTransparency = isStealthMode and 0.5 or 0
	GuiElements.fovChangerButton.TextTransparency = isStealthMode and 0.3 or 0
	GuiElements.resetFovButton.BackgroundTransparency = isStealthMode and 0.5 or 0
	GuiElements.resetFovButton.TextTransparency = isStealthMode and 0.3 or 0
	setSliderEnabled(GuiElements.camFovSliderContainer, not isStealthMode and isFOVChangerEnabled)
	local listTitle = Instance.new("TextLabel", mainFrame)
	listTitle.Size = UDim2.new(1, -THEME.Padding*2, 0, THEME.SmallElementHeight)
	listTitle.Position = UDim2.fromOffset(THEME.Padding, 0)
	listTitle.BackgroundTransparency = 1
	listTitle.Text = "NEARBY ENTITIES"
	listTitle.TextColor3 = THEME.TextDisabled
	listTitle.Font = THEME.Font
	listTitle.TextSize = THEME.SmallTextSize
	listTitle.TextXAlignment = Enum.TextXAlignment.Left
	listTitle.LayoutOrder = 8
	local playerListHeight = 90 * GUI_SIZE_MULTIPLIER
	local playerListFrame = Instance.new("ScrollingFrame", mainFrame)
	playerListFrame.Size = UDim2.new(1, 0, 0, playerListHeight)
	playerListFrame.BackgroundTransparency = 1
	playerListFrame.BackgroundColor3 = THEME.Background
	playerListFrame.BorderSizePixel = 0
	playerListFrame.LayoutOrder = 9
	playerListFrame.ScrollBarThickness = 3
	playerListFrame.ScrollBarImageColor3 = THEME.Accent
	playerListFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	playerListFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
	playerListFrame.ClipsDescendants = true
	local listFrameCorner = Instance.new("UICorner", playerListFrame)
	listFrameCorner.CornerRadius = UDim.new(0, THEME.CornerRadius / 2)
	local listStroke = Instance.new("UIStroke", playerListFrame)
	listStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	listStroke.Color = THEME.Tertiary
	listStroke.Thickness = THEME.StrokeThickness
	listStroke.Transparency = 0.6
	local playerListLayout = Instance.new("UIListLayout", playerListFrame)
	playerListLayout.Padding = UDim.new(0, 3)
	playerListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	playerListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	playerListLayout.FillDirection = Enum.FillDirection.Vertical
	local listPadding = Instance.new("UIPadding", playerListFrame)
	listPadding.PaddingLeft = UDim.new(0, 2)
	listPadding.PaddingRight = UDim.new(0, 2)
	listPadding.PaddingTop = UDim.new(0, 2)
	listPadding.PaddingBottom = UDim.new(0, 2)
	GuiElements.playerListFrame = playerListFrame
	GuiElements.playerListLayout = playerListLayout
	local footerFrame = Instance.new("Frame", mainFrame)
	footerFrame.Size = UDim2.new(1, 0, 0, 0)
	footerFrame.AutomaticSize = Enum.AutomaticSize.Y
	footerFrame.BackgroundTransparency = 1
	footerFrame.LayoutOrder = 100
	local footerLayout = Instance.new("UIListLayout", footerFrame)
	footerLayout.Padding = UDim.new(0, 0)
	footerLayout.SortOrder = Enum.SortOrder.LayoutOrder
	footerLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	footerLayout.FillDirection = Enum.FillDirection.Vertical
	local disclaimerLabel = Instance.new("TextLabel", footerFrame)
	disclaimerLabel.Name = "DisclaimerLabel"
	disclaimerLabel.Size = UDim2.new(1, -THEME.Padding*2, 0, THEME.DisclaimerSize + 4)
	disclaimerLabel.BackgroundTransparency = 1
	disclaimerLabel.Font = THEME.Font
	disclaimerLabel.Text = "Module executed via THE MIST HUB."
	disclaimerLabel.TextColor3 = THEME.TextDisabled
	disclaimerLabel.TextSize = THEME.DisclaimerSize
	disclaimerLabel.TextWrapped = false
	disclaimerLabel.TextXAlignment = Enum.TextXAlignment.Center
	disclaimerLabel.LayoutOrder = 1
	local disclaimerPadding = Instance.new("UIPadding", disclaimerLabel)
	disclaimerPadding.PaddingTop = UDim.new(0, 4)
	
	local function animateBackground()
		while gui and gui.Parent and mainFrame and mainFrame.Parent do
			local animSpeed = 30
			local startOffset = Vector2.new(-1, -1)
			local endOffset = Vector2.new(2, 2)
			bgGradient.Offset = startOffset
			local bgTween = TweenService:Create(bgGradient, TweenInfo.new(animSpeed, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Offset = endOffset})
			bgTween:Play()
			bgTween.Completed:Wait()
			task.wait(0.1)
		end
	end
	task.spawn(animateBackground)

	local panelTween = nil
	local slideTweenInfo = TweenInfo.new(0.35, Enum.EasingStyle.Cubic, Enum.EasingDirection.Out)

	local invisibleToggleArea = Instance.new("TextButton", gui)
	invisibleToggleArea.Name = "InvisibleToggleArea"
	invisibleToggleArea.Size = UDim2.new(0, 80, 0, 80)
	invisibleToggleArea.AnchorPoint = Vector2.new(0, 1)
	invisibleToggleArea.Position = UDim2.new(0, 10, 1, -10)
	invisibleToggleArea.BackgroundTransparency = 1
	invisibleToggleArea.Text = ""
	invisibleToggleArea.ZIndex = 10
	
	local hiddenPosition = UDim2.new(0, 0, 0.5, 0)
	
	invisibleToggleArea.MouseButton1Click:Connect(function()
		panelVisible = not panelVisible
		hideTooltip()

		if panelTween and panelTween.PlaybackState == Enum.PlaybackState.Playing then
			panelTween:Cancel()
		end
		
		if panelVisible then
			mainFrame.Visible = true
			task.wait()
			
			local targetPixelX = mainFrame.AbsoluteSize.X + 10
			local unscaledOffsetX = targetPixelX / uiScale.Scale
			local visiblePosition = UDim2.new(0, unscaledOffsetX, 0.5, 0)
			
			mainFrame.Position = hiddenPosition
			
			panelTween = TweenService:Create(mainFrame, slideTweenInfo, {Position = visiblePosition})
			panelTween:Play()
		else
			panelTween = TweenService:Create(mainFrame, slideTweenInfo, {Position = hiddenPosition})
			panelTween.Completed:Connect(function(state)
				if state == Enum.TweenStatus.Completed and not panelVisible then
					mainFrame.Visible = false
				end
			end)
			panelTween:Play()
		end

		updateFOVCircle()
		updateAllExcludedLabelsVisibility()
	end)


	local listHoverTweenInfo = TweenInfo.new(0.1)
	local function updatePlayerListGUI()
		if not GuiElements.playerListFrame or not GuiElements.playerListFrame.Parent then return end
		if not character or not character:FindFirstChild("HumanoidRootPart") then return end
		
		local existingButtons = {}
		for _, child in ipairs(GuiElements.playerListFrame:GetChildren()) do
			if child:IsA("TextButton") and child.Name:match("_Entry$") then
				local userIdAttr = child:GetAttribute("PlayerUserId")
				if userIdAttr then existingButtons[userIdAttr] = child end
			end
		end

		local pinnedEntries = {}
		local nearbyEntries = {}
		local playerRootPos = character.HumanoidRootPart.Position
		local displayRange = 50

		for p, isExcluded in pairs(excludedPlayers) do
			if isExcluded and p and p.Parent then
				local dist = nil
				if p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
					dist = (playerRootPos - p.Character.HumanoidRootPart.Position).Magnitude
				end
				table.insert(pinnedEntries, {Player = p, Dist = dist, Pinned = true})
			end
		end

		for _, p in pairs(Players:GetPlayers()) do
			if p ~= player and not excludedPlayers[p] and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
				local targetHumanoid = p.Character:FindFirstChildOfClass("Humanoid")
				if targetHumanoid and targetHumanoid.Health > 0 then
					local targetRootPos = p.Character.HumanoidRootPart.Position
					local dist = (playerRootPos - targetRootPos).Magnitude
					if dist <= displayRange then
						table.insert(nearbyEntries, {Player = p, Dist = dist, Pinned = false})
					end
				end
			end
		end

		table.sort(nearbyEntries, function(a, b) return a.Dist < b.Dist end)

		local allEntries = {}
		for _, entry in ipairs(pinnedEntries) do table.insert(allEntries, entry) end
		for _, entry in ipairs(nearbyEntries) do table.insert(allEntries, entry) end

		local playersInList = {}
		for i, data in ipairs(allEntries) do
			local p = data.Player
			local userId = p.UserId
			playersInList[userId] = true
			local btn = existingButtons[userId]
			
			local distText
			if data.Pinned then
				distText = data.Dist and (data.Dist > displayRange) and "PINNED" or (data.Dist and (math.floor(data.Dist) .. "m") or "PINNED")
			else
				distText = math.floor(data.Dist) .. "m"
			end

			if btn then
				btn.LayoutOrder = i
				local distLabel = btn:FindFirstChild("DistLabel", true)
				if distLabel then distLabel.Text = distText end
				local isExcluded = excludedPlayers[p]
				local nameLabel = btn:FindFirstChild("NameLabel", true)
				if nameLabel then nameLabel.TextColor3 = isExcluded and THEME.RefExcludedColor or THEME.TextPlayerListNormal end
				local excludeIcon = btn:FindFirstChild("ExcludeIcon", true)
				if excludeIcon then
					excludeIcon.Text = isExcluded and "✖" or "✔"
					excludeIcon.TextColor3 = isExcluded and THEME.ExcludedIcon or THEME.Success
					updateExcludedLabel(p)
				end
				existingButtons[userId] = nil
			else
				btn = Instance.new("TextButton")
				btn.Name = p.Name .. "_Entry"
				btn.Size = UDim2.new(1, 0, 0, THEME.SmallElementHeight)
				btn.BackgroundColor3 = THEME.Primary
				btn.BackgroundTransparency = 0.1
				btn.Text = ""
				btn.LayoutOrder = i
				btn:SetAttribute("PlayerUserId", userId)
				btn.Parent = GuiElements.playerListFrame
				local btnCorner = Instance.new("UICorner", btn)
				btnCorner.CornerRadius = UDim.new(0, THEME.CornerRadius / 2)
				local itemStroke = Instance.new("UIStroke", btn)
				itemStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
				itemStroke.Color = THEME.Tertiary
				itemStroke.Thickness = THEME.StrokeThickness
				itemStroke.Transparency = 0.7
				local itemPadding = Instance.new("UIPadding", btn)
				itemPadding.PaddingLeft = UDim.new(0, 5)
				itemPadding.PaddingRight = UDim.new(0, 5)
				local excludeIcon = Instance.new("TextLabel", btn)
				excludeIcon.Name = "ExcludeIcon"
				excludeIcon.Size = UDim2.fromOffset(12, 12)
				excludeIcon.Position=UDim2.fromScale(0,0.5)
				excludeIcon.AnchorPoint=Vector2.new(0,0.5)
				excludeIcon.BackgroundTransparency = 1
				excludeIcon.Font = Enum.Font.SourceSansBold
				local isExcluded = excludedPlayers[p]
				excludeIcon.Text = isExcluded and "✖" or "✔"
				excludeIcon.TextColor3 = isExcluded and THEME.ExcludedIcon or THEME.Success
				excludeIcon.TextSize = 14
				local teamColorIndicator = Instance.new("Frame", btn)
				teamColorIndicator.Size = UDim2.fromOffset(5, 12)
				teamColorIndicator.Position=UDim2.fromOffset(18,0)+UDim2.fromScale(0,0.5)
				teamColorIndicator.AnchorPoint=Vector2.new(0,0.5)
				teamColorIndicator.BackgroundColor3 = p.Team and p.Team.TeamColor.Color or Color3.fromRGB(90,90,90)
				teamColorIndicator.BorderSizePixel = 0
				local teamCorner = Instance.new("UICorner", teamColorIndicator)
				teamCorner.CornerRadius = UDim.new(0, 2)
				local nameLabel = Instance.new("TextLabel", btn)
				nameLabel.Name = "NameLabel"
				nameLabel.Size = UDim2.new(1, -55, 1, 0)
				nameLabel.Position=UDim2.fromOffset(25,0)
				nameLabel.BackgroundTransparency = 1
				nameLabel.Font = THEME.Font
				nameLabel.Text = p.Name
				nameLabel.TextColor3 = isExcluded and THEME.RefExcludedColor or THEME.TextPlayerListNormal
				nameLabel.TextSize = THEME.SmallTextSize
				nameLabel.TextXAlignment = Enum.TextXAlignment.Left
				local distLabel = Instance.new("TextLabel", btn)
				distLabel.Name = "DistLabel"
				distLabel.Size = UDim2.new(0, 35, 1, 0)
				distLabel.AnchorPoint=Vector2.new(1,0.5)
				distLabel.Position=UDim2.fromScale(1,0.5)
				distLabel.BackgroundTransparency = 1
				distLabel.Font = THEME.Font
				distLabel.Text = distText
				distLabel.TextColor3 = THEME.TextDisabled
				distLabel.TextSize = THEME.SmallTextSize
				distLabel.TextXAlignment = Enum.TextXAlignment.Right
				updateExcludedLabel(p)
				btn.MouseEnter:Connect(function()
					TweenService:Create(btn, listHoverTweenInfo, {BackgroundTransparency = 0}):Play()
				end)
				btn.MouseLeave:Connect(function()
					TweenService:Create(btn, listHoverTweenInfo, {BackgroundTransparency = 0.1}):Play()
				end)
				btn.MouseButton1Click:Connect(function()
					excludedPlayers[p] = not excludedPlayers[p]
					updateExcludedLabel(p)
				end)
			end
		end

		for _, oldBtn in pairs(existingButtons) do oldBtn:Destroy() end
	end
	GuiElements.autoTargetButton.MouseButton1Click:Connect(function()
		isAutoTargetEnabled = not isAutoTargetEnabled
		local newStateText = isAutoTargetEnabled and "TARGET: ON" or "TARGET: OFF"
		local newTextColor = isAutoTargetEnabled and THEME.Success or THEME.Error
		local button = GuiElements.autoTargetButton
		button.Text = newStateText
		button:SetAttribute("CurrentTextColor", newTextColor)
		TweenService:Create(button, TextColorTweenInfo, { TextColor3 = newTextColor }):Play()
		updateFOVCircle()
	end)
	GuiElements.espButton.MouseButton1Click:Connect(function()
		if isStealthMode then return end
		toggleESP(not isESPEnabled)
	end)
	GuiElements.fovChangerButton.MouseButton1Click:Connect(function()
		if isStealthMode then return end
		isFOVChangerEnabled = not isFOVChangerEnabled
		local newStateText = isFOVChangerEnabled and "FOV: ON" or "FOV: OFF"
		local newTextColor = isFOVChangerEnabled and THEME.Success or THEME.Error
		local button = GuiElements.fovChangerButton
		button.Text = newStateText
		button:SetAttribute("CurrentTextColor", newTextColor)
		TweenService:Create(button, TextColorTweenInfo, { TextColor3 = newTextColor }):Play()
		setSliderEnabled(GuiElements.camFovSliderContainer, isFOVChangerEnabled)
		if isFOVChangerEnabled then
			Camera.FieldOfView = currentCameraFOV
			setSliderValue(GuiElements.camFovSliderContainer, currentCameraFOV)
		else
			Camera.FieldOfView = gameDefaultFOV
			setSliderValue(GuiElements.camFovSliderContainer, gameDefaultFOV)
		end
		updateFOVCircle()
	end)
	GuiElements.resetFovButton.MouseButton1Click:Connect(function()
		if isStealthMode then return end
		currentCameraFOV = gameDefaultFOV
		Camera.FieldOfView = gameDefaultFOV
		setSliderValue(GuiElements.camFovSliderContainer, gameDefaultFOV)
		updateFOVCircle()
		local button = GuiElements.resetFovButton
		local originalTextColor = THEME.ButtonText
		button:SetAttribute("CurrentTextColor", THEME.Accent)
		TweenService:Create(button, TextColorTweenInfo, {TextColor3 = THEME.Accent}):Play()
		task.delay(THEME.TextColorFadeDuration * 1.1, function()
			if button and button.Parent then
				button:SetAttribute("CurrentTextColor", originalTextColor)
				TweenService:Create(button, TextColorTweenInfo, {TextColor3 = originalTextColor}):Play()
			end
		end)
	end)
	local lastUpdate = 0
	local updateInterval = 0.5
	RunService.Heartbeat:Connect(function()
		local currentTime = tick()
		if panelVisible and (currentTime - lastUpdate >= updateInterval) then
			pcall(updatePlayerListGUI)
			lastUpdate = currentTime
		end
	end)
	local initialAutoTargetTextColor = isAutoTargetEnabled and THEME.Success or THEME.Error
	GuiElements.autoTargetButton.TextColor3 = initialAutoTargetTextColor
	GuiElements.autoTargetButton:SetAttribute("CurrentTextColor", initialAutoTargetTextColor)
	local initialEspTextColor = isESPEnabled and THEME.Success or THEME.Error
	GuiElements.espButton.TextColor3 = initialEspTextColor
	GuiElements.espButton:SetAttribute("CurrentTextColor", initialEspTextColor)
	local initialFovTextColor = isFOVChangerEnabled and THEME.Success or THEME.Error
	GuiElements.fovChangerButton.TextColor3 = initialFovTextColor
	GuiElements.fovChangerButton:SetAttribute("CurrentTextColor", initialFovTextColor)
	GuiElements.resetFovButton.TextColor3 = THEME.ButtonText
	GuiElements.resetFovButton:SetAttribute("CurrentTextColor", THEME.ButtonText)
	setSliderEnabled(GuiElements.camFovSliderContainer, not isStealthMode and isFOVChangerEnabled)
	setSliderValue(GuiElements.camFovSliderContainer, isFOVChangerEnabled and currentCameraFOV or gameDefaultFOV)
	setSliderValue(GuiElements.targetFovSliderContainer, targetingFOV)
	gui.Destroying:Connect(function()
		if scaleConnection then
			scaleConnection:Disconnect()
		end
	end)
	return gui
end

local MainGui = nil
local success, err = pcall(function()
	MainGui = createBeautifulGUI()
	fovCircle = createDrawingCircle()
	Camera.FieldOfView = isFOVChangerEnabled and currentCameraFOV or gameDefaultFOV
	toggleESP(isESPEnabled)
	updateFOVCircle()
	updateAllExcludedLabelsVisibility()
	setupToolListener(findTool())
	local tapRaycastParams = RaycastParams.new()
	tapRaycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	tapRaycastParams.IgnoreWater = true
	local function handleTapExclude(input, gameProcessedEvent)
		if excludeMethod ~= "Touch" then return end
		if gameProcessedEvent then return end
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			local unitRay = Camera:ScreenPointToRay(input.Position.X, input.Position.Y)
			tapRaycastParams.FilterDescendantsInstances = {character, Storage, MainGui}
			local rayResult = workspace:Raycast(unitRay.Origin, unitRay.Direction * 500, tapRaycastParams)
			if rayResult and rayResult.Instance then
				local hitPart = rayResult.Instance
				local hitCharacter = hitPart:FindFirstAncestorWhichIsA("Model")
				if hitCharacter and hitCharacter:FindFirstChildOfClass("Humanoid") then
					local targetPlayer = Players:GetPlayerFromCharacter(hitCharacter)
					if targetPlayer and targetPlayer ~= player then
						excludedPlayers[targetPlayer] = not excludedPlayers[targetPlayer]
						updateExcludedLabel(targetPlayer)
						if isESPEnabled then
							local h = Storage:FindFirstChild(targetPlayer.Name)
							if h and h:IsA("Highlight") then
								local originalColor = h.FillColor
								local feedbackColor = excludedPlayers[targetPlayer] and THEME.Error or THEME.Success
								h.FillColor = feedbackColor
								h.FillTransparency = 0.3
								task.delay(0.3, function()
									if h and h.Parent then
										h.FillColor = originalColor
										h.FillTransparency = 0.5
									end
								end)
							end
						end
					end
				end
			end
		end
	end
	UserInputService.InputBegan:Connect(handleTapExclude)
	local function setupPlayerListeners(plr)
		if plr == player then return end
		task.spawn(function()
			task.wait(0.1)
			if not plr or not plr.Parent then return end
			if excludedPlayers[plr] then updateExcludedLabel(plr) end
			if isESPEnabled then applyHighlight(plr) end
			plr.CharacterAdded:Connect(function(newChar)
				task.wait(0.1)
				if not plr or not plr.Parent then return end
				if excludedPlayers[plr] then updateExcludedLabel(plr) end
				if isESPEnabled then applyHighlight(plr) end
			end)
			plr.CharacterRemoving:Connect(function(oldChar)
				local head = oldChar and oldChar:FindFirstChild("Head")
				local existingLabel = head and head:FindFirstChild("ExcludeLabel")
				if existingLabel then existingLabel:Destroy() end
				local h = Storage:FindFirstChild(plr.Name)
				if h then h.Adornee = nil end
			end)
		end)
	end
	Players.PlayerAdded:Connect(function(newPlayer)
		if newPlayer ~= player then setupPlayerListeners(newPlayer) end
	end)
	Players.PlayerRemoving:Connect(function(leavingPlayer)
		excludedPlayers[leavingPlayer] = nil
		removeHighlight(leavingPlayer)
	end)
	for _, existingPlayer in pairs(Players:GetPlayers()) do
		setupPlayerListeners(existingPlayer)
	end
	player.CharacterAdded:Connect(function(newCharacter)
		character = newCharacter
		task.wait(0.2)
		backpack = player:FindFirstChild("Backpack") or player:WaitForChild("Backpack", 5)
		setupToolListener(findTool())
		for targetPlayer, isExcluded in pairs(excludedPlayers) do
			if isExcluded then updateExcludedLabel(targetPlayer) end
		end
		newCharacter.ChildAdded:Connect(function(child)
			if child:IsA("Tool") then
				setupToolListener(child)
			end
		end)
		newCharacter.ChildRemoved:Connect(function(child)
			if child == currentTool then
				setupToolListener(nil)
			end
		end)
	end)
	if character then
		character.ChildAdded:Connect(function(child)
			if child:IsA("Tool") then
				setupToolListener(child)
			end
		end)
		character.ChildRemoved:Connect(function(child)
			if child == currentTool then
				setupToolListener(nil)
			end
		end)
	end
	player.ChildAdded:Connect(function(child)
		if child.Name == "Backpack" and child:IsA("Backpack") then
			backpack = child
		end
	end)
	RunService.RenderStepped:Connect(function(dt)
		if not character or not character.Parent then
			character = player.Character
			if not character then return end
		end
		local currentlyEquippedTool = nil
		if character then currentlyEquippedTool = character:FindFirstChildOfClass("Tool") end
		if currentlyEquippedTool ~= currentTool then
			setupToolListener(currentlyEquippedTool)
		end
		if currentTool and not currentTool.Enabled and currentEffectiveCooldown > 0 then
			if tick() - lastShotTime >= currentEffectiveCooldown then
				pcall(function() currentTool.Enabled = true end)
				currentEffectiveCooldown = 0
			end
		end
		pcall(updateFOVCircle)
		pcall(shoot)
	end)
end)
if not success then
	warn("THE MIST Triggerbot Module (Delay Switcher) failed to initialize:", err)
	if MainGui and MainGui.Parent then MainGui:Destroy() end
	if Storage and Storage.Parent then Storage:Destroy() end
	if fovCircle and fovCircle.Destroy then fovCircle:Destroy(); fovCircle = nil end
	if activatedConnection then activatedConnection:Disconnect() end
end
if script and script:IsA("Script") then
	script.Destroying:Connect(function()
		if currentTool and currentTool.Parent and not currentTool.Enabled then
			pcall(function() currentTool.Enabled = true end)
		end
		if activatedConnection then activatedConnection:Disconnect(); activatedConnection = nil end
		if MainGui and MainGui.Parent then MainGui:Destroy() end
		if Storage and Storage.Parent then Storage:Destroy() end
		if fovCircle and fovCircle.Destroy then fovCircle:Destroy(); fovCircle = nil end
	end)
end
	-- ▲▲▲ YOUR SCRIPT CODE GOES ABOVE THIS LINE ▲▲▲
end

-- ================================================================= --
-- CHECK FOR SAVED KEY OR KEYLESS MODE
-- ================================================================= --

if isfile and isfile(KEY_FILENAME) then
	local savedKey = readfile(KEY_FILENAME)
	if savedKey and savedKey ~= "" then
		local result = JunkieProtected.ValidateKey({ Key = savedKey })
		if result == "valid" then
			RunMainScript()
			return
		end
	end
end

local keylessCheck = JunkieProtected.IsKeylessMode()
if keylessCheck and keylessCheck.keyless_mode then
	RunMainScript()
	return
end

-- ================================================================= --
-- CREATE SCREEN GUI (PROFESSIONAL UI)
-- ================================================================= --

local gui = Instance.new("ScreenGui")
gui.Name = "TheMistHubPro"
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.Parent = playerGui

-- ================================================================= --
-- ANIMATED GRADIENT BACKGROUND
-- ================================================================= --

local bgFrame = Instance.new("Frame")
bgFrame.Name = "Background"
bgFrame.Size = UDim2.new(1, 0, 1, 0)
bgFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 15)
bgFrame.BorderSizePixel = 0
bgFrame.ZIndex = 1
bgFrame.Parent = gui

local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 217, 255)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(181, 55, 242)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 217, 255))
}
gradient.Rotation = 45
gradient.Parent = bgFrame

task.spawn(function()
	while bgFrame and bgFrame.Parent do
		for i = 0, 360, 2 do
			if not bgFrame or not bgFrame.Parent then break end
			gradient.Rotation = i
			task.wait(0.05)
		end
	end
end)

-- ================================================================= --
-- PARTICLE SYSTEM
-- ================================================================= --

local particleContainer = Instance.new("Frame")
particleContainer.Name = "Particles"
particleContainer.Size = UDim2.new(1, 0, 1, 0)
particleContainer.BackgroundTransparency = 1
particleContainer.ZIndex = 2
particleContainer.Parent = gui

local particles = {}
local particleCount = 50

for i = 1, particleCount do
	local particle = Instance.new("Frame")
	particle.Size = UDim2.new(0, math.random(2, 4), 0, math.random(2, 4))
	particle.Position = UDim2.new(math.random(), 0, math.random(), 0)
	particle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	particle.BackgroundTransparency = math.random(30, 70) / 100
	particle.BorderSizePixel = 0
	particle.Parent = particleContainer

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(1, 0)
	corner.Parent = particle

	table.insert(particles, {
		frame = particle,
		vx = (math.random() - 0.5) * 0.001,
		vy = (math.random() - 0.5) * 0.001
	})
end

RunService.Heartbeat:Connect(function()
	for _, p in ipairs(particles) do
		if p.frame and p.frame.Parent then
			local pos = p.frame.Position
			local newX = pos.X.Scale + p.vx
			local newY = pos.Y.Scale + p.vy

			if newX < 0 or newX > 1 then p.vx = -p.vx end
			if newY < 0 or newY > 1 then p.vy = -p.vy end

			p.frame.Position = UDim2.new(
				math.clamp(newX, 0, 1), 0,
				math.clamp(newY, 0, 1), 0
			)
		end
	end
end)

-- ================================================================= --
-- SPLASH SCREEN
-- ================================================================= --

local splash = Instance.new("Frame")
splash.Name = "Splash"
splash.Size = UDim2.new(1, 0, 1, 0)
splash.BackgroundColor3 = Color3.fromRGB(10, 10, 15)
splash.BorderSizePixel = 0
splash.ZIndex = 100
splash.Parent = gui

local splashLogo = Instance.new("TextLabel")
splashLogo.Size = UDim2.new(0, 400, 0, 80)
splashLogo.Position = UDim2.fromScale(0.5, 0.5)
splashLogo.AnchorPoint = Vector2.new(0.5, 0.5)
splashLogo.Text = "THE MIST HUB"
splashLogo.TextSize = 48
splashLogo.Font = Enum.Font.GothamBold
splashLogo.TextColor3 = Color3.fromRGB(255, 255, 255)
splashLogo.BackgroundTransparency = 1
splashLogo.TextTransparency = 1
splashLogo.TextStrokeTransparency = 0.5
splashLogo.Parent = splash

local logoGradient = Instance.new("UIGradient")
logoGradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 217, 255)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(181, 55, 242))
}
logoGradient.Parent = splashLogo

task.spawn(function()
	TweenService:Create(splashLogo, TweenInfo.new(0.6, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		TextTransparency = 0,
		Size = UDim2.new(0, 450, 0, 90)
	}):Play()

	task.wait(1.5)

	TweenService:Create(splash, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
		BackgroundTransparency = 1
	}):Play()
	TweenService:Create(splashLogo, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
		TextTransparency = 1
	}):Play()

	task.wait(0.5)
	splash:Destroy()
end)

-- ================================================================= --
-- MAIN WINDOW
-- ================================================================= --

local main = Instance.new("Frame")
main.Name = "MainWindow"
main.BackgroundColor3 = Color3.fromRGB(18, 18, 26)
main.BackgroundTransparency = 0.3
main.AnchorPoint = Vector2.new(0.5, 0.5)
main.Position = UDim2.fromScale(0.5, 0.5)
main.Size = UDim2.new(0, 0, 0, 0)
main.BorderSizePixel = 0
main.ZIndex = 10
main.Parent = gui

local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 20)
mainCorner.Parent = main

local mainStroke = Instance.new("UIStroke")
mainStroke.Color = Color3.fromRGB(100, 200, 255)
mainStroke.Thickness = 2
mainStroke.Transparency = 0.3
mainStroke.Parent = main

local glow = Instance.new("Frame")
glow.Name = "Glow"
glow.Size = UDim2.new(1, 60, 1, 60)
glow.Position = UDim2.fromScale(0.5, 0.5)
glow.AnchorPoint = Vector2.new(0.5, 0.5)
glow.BackgroundColor3 = Color3.fromRGB(0, 217, 255)
glow.BackgroundTransparency = 0.9
glow.BorderSizePixel = 0
glow.ZIndex = 9
glow.Parent = main

local glowCorner = Instance.new("UICorner")
glowCorner.CornerRadius = UDim.new(0, 30)
glowCorner.Parent = glow

-- ================================================================= --
-- CLOSE BUTTON
-- ================================================================= --

local closeBtn = Instance.new("TextButton")
closeBtn.Name = "CloseButton"
closeBtn.Size = UDim2.new(0, 35, 0, 35)
closeBtn.Position = UDim2.new(1, -45, 0, 10)
closeBtn.BackgroundColor3 = Color3.fromRGB(255, 60, 60)
closeBtn.BackgroundTransparency = 1
closeBtn.Text = "×"
closeBtn.TextSize = 24
closeBtn.TextColor3 = Color3.new(1, 1, 1)
closeBtn.TextTransparency = 1
closeBtn.Font = Enum.Font.GothamBold
closeBtn.ZIndex = 11
closeBtn.Parent = main

local closeBtnCorner = Instance.new("UICorner")
closeBtnCorner.CornerRadius = UDim.new(1, 0)
closeBtnCorner.Parent = closeBtn

closeBtn.MouseEnter:Connect(function()
	TweenService:Create(closeBtn, TweenInfo.new(0.2), {
		BackgroundColor3 = Color3.fromRGB(255, 100, 100),
		Size = UDim2.new(0, 38, 0, 38)
	}):Play()
end)

closeBtn.MouseLeave:Connect(function()
	TweenService:Create(closeBtn, TweenInfo.new(0.2), {
		BackgroundColor3 = Color3.fromRGB(255, 60, 60),
		Size = UDim2.new(0, 35, 0, 35)
	}):Play()
end)

closeBtn.MouseButton1Click:Connect(function()
	TweenService:Create(main, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0)
	}):Play()
	task.wait(0.3)
	gui:Destroy()
end)

-- ================================================================= --
-- TITLE & SUBTITLE
-- ================================================================= --

local title = Instance.new("TextLabel")
title.Name = "Title"
title.Size = UDim2.new(1, -40, 0, 60)
title.Position = UDim2.new(0, 20, 0, 10)
title.Text = "🔐 THE MIST HUB"
title.TextSize = 28
title.Font = Enum.Font.GothamBold
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.BackgroundTransparency = 1
title.TextTransparency = 1
title.TextStrokeTransparency = 0.8
title.ZIndex = 11
title.Parent = main

local titleGradient = Instance.new("UIGradient")
titleGradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 217, 255)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(181, 55, 242))
}
titleGradient.Parent = title

local subtitle = Instance.new("TextLabel")
subtitle.Name = "Subtitle"
subtitle.Size = UDim2.new(1, -40, 0, 25)
subtitle.Position = UDim2.new(0, 20, 0, 55)
subtitle.Text = "Premium Authentication System"
subtitle.TextSize = 14
subtitle.Font = Enum.Font.Gotham
subtitle.TextColor3 = Color3.fromRGB(180, 180, 180)
subtitle.BackgroundTransparency = 1
subtitle.TextTransparency = 1
subtitle.ZIndex = 11
subtitle.Parent = main

-- ================================================================= --
-- INPUT FIELD
-- ================================================================= --

local inputContainer = Instance.new("Frame")
inputContainer.Name = "InputContainer"
inputContainer.Size = UDim2.new(0.9, 0, 0, 50)
inputContainer.Position = UDim2.new(0.05, 0, 0, 100)
inputContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
inputContainer.BackgroundTransparency = 1
inputContainer.BorderSizePixel = 0
inputContainer.ZIndex = 11
inputContainer.Parent = main

local inputCorner = Instance.new("UICorner")
inputCorner.CornerRadius = UDim.new(0, 12)
inputCorner.Parent = inputContainer

local inputStroke = Instance.new("UIStroke")
inputStroke.Color = Color3.fromRGB(80, 80, 100)
inputStroke.Thickness = 1
inputStroke.Transparency = 1
inputStroke.Parent = inputContainer

local input = Instance.new("TextBox")
input.Name = "KeyInput"
input.Size = UDim2.new(1, -20, 1, -10)
input.Position = UDim2.new(0, 10, 0, 5)
input.BackgroundTransparency = 1
input.PlaceholderText = "Enter your key here..."
input.PlaceholderColor3 = Color3.fromRGB(120, 120, 140)
input.TextSize = 16
input.TextColor3 = Color3.fromRGB(255, 255, 255)
input.TextTransparency = 1
input.Font = Enum.Font.Gotham
input.TextXAlignment = Enum.TextXAlignment.Left
input.ClearTextOnFocus = false
input.ZIndex = 12
input.Parent = inputContainer

input.Focused:Connect(function()
	TweenService:Create(inputStroke, TweenInfo.new(0.2), {
		Color = Color3.fromRGB(0, 217, 255),
		Transparency = 0
	}):Play()
	TweenService:Create(inputContainer, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.5
	}):Play()
end)

input.FocusLost:Connect(function()
	TweenService:Create(inputStroke, TweenInfo.new(0.2), {
		Color = Color3.fromRGB(80, 80, 100),
		Transparency = 0.5
	}):Play()
	TweenService:Create(inputContainer, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.7
	}):Play()
end)

-- ================================================================= --
-- NOTIFICATION SYSTEM
-- ================================================================= --

local function notify(message, success)
	local notif = Instance.new("Frame")
	notif.Name = "Notification"
	notif.Size = UDim2.new(0, 350, 0, 60)
	notif.Position = UDim2.new(0.5, -175, 1, 20)
	notif.BackgroundColor3 = success and Color3.fromRGB(40, 180, 99) or Color3.fromRGB(231, 76, 60)
	notif.BackgroundTransparency = 0.1
	notif.BorderSizePixel = 0
	notif.ZIndex = 200
	notif.Parent = gui

	local notifCorner = Instance.new("UICorner")
	notifCorner.CornerRadius = UDim.new(0, 12)
	notifCorner.Parent = notif

	local notifStroke = Instance.new("UIStroke")
	notifStroke.Color = success and Color3.fromRGB(20, 230, 120) or Color3.fromRGB(255, 100, 100)
	notifStroke.Thickness = 2
	notifStroke.Parent = notif

	local icon = Instance.new("TextLabel")
	icon.Size = UDim2.new(0, 40, 1, 0)
	icon.Position = UDim2.new(0, 10, 0, 0)
	icon.BackgroundTransparency = 1
	icon.Text = success and "✓" or "✗"
	icon.TextSize = 28
	icon.TextColor3 = Color3.new(1, 1, 1)
	icon.Font = Enum.Font.GothamBold
	icon.ZIndex = 201
	icon.Parent = notif

	local text = Instance.new("TextLabel")
	text.Size = UDim2.new(1, -60, 1, 0)
	text.Position = UDim2.new(0, 50, 0, 0)
	text.BackgroundTransparency = 1
	text.Text = message
	text.TextSize = 15
	text.TextColor3 = Color3.new(1, 1, 1)
	text.Font = Enum.Font.GothamSemibold
	text.TextXAlignment = Enum.TextXAlignment.Left
	text.TextWrapped = true
	text.ZIndex = 201
	text.Parent = notif

	local progress = Instance.new("Frame")
	progress.Size = UDim2.new(1, 0, 0, 3)
	progress.Position = UDim2.new(0, 0, 1, -3)
	progress.BackgroundColor3 = Color3.new(1, 1, 1)
	progress.BorderSizePixel = 0
	progress.ZIndex = 202
	progress.Parent = notif

	local slideIn = TweenService:Create(notif, 
		TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out), 
		{Position = UDim2.new(0.5, -175, 1, -80)})
	slideIn:Play()

	TweenService:Create(progress, TweenInfo.new(3, Enum.EasingStyle.Linear), {
		Size = UDim2.new(0, 0, 0, 3)
	}):Play()

	task.delay(3, function()
		local slideOut = TweenService:Create(notif, 
			TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In), 
			{Position = UDim2.new(0.5, -175, 1, 20)})
		slideOut:Play()
		slideOut.Completed:Connect(function()
			notif:Destroy()
		end)
	end)
end

-- ================================================================= --
-- BUTTON CREATION FUNCTION
-- ================================================================= --

local function createButton(text, yPos, color1, color2, icon)
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(0.9, 0, 0, 50)
	btn.Position = UDim2.new(0.05, 0, 0, yPos)
	btn.BackgroundColor3 = color1
	btn.BackgroundTransparency = 1
	btn.Text = icon .. " " .. text
	btn.TextSize = 18
	btn.TextColor3 = Color3.new(1, 1, 1)
	btn.TextTransparency = 1
	btn.Font = Enum.Font.GothamBold
	btn.BorderSizePixel = 0
	btn.ZIndex = 11
	btn.Parent = main

	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 12)
	btnCorner.Parent = btn

	local btnGradient = Instance.new("UIGradient")
	btnGradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, color1),
		ColorSequenceKeypoint.new(1, color2)
	}
	btnGradient.Rotation = 45
	btnGradient.Parent = btn

	local btnStroke = Instance.new("UIStroke")
	btnStroke.Color = color2
	btnStroke.Thickness = 1
	btnStroke.Transparency = 1
	btnStroke.Parent = btn

	local originalSize = btn.Size

	btn.MouseEnter:Connect(function()
		TweenService:Create(btn, TweenInfo.new(0.2), {
			BackgroundTransparency = 0,
			Size = UDim2.new(0.92, 0, 0, 52)
		}):Play()
		TweenService:Create(btnStroke, TweenInfo.new(0.2), {
			Thickness = 2,
			Transparency = 0
		}):Play()
	end)

	btn.MouseLeave:Connect(function()
		TweenService:Create(btn, TweenInfo.new(0.2), {
			BackgroundTransparency = 0.2,
			Size = originalSize
		}):Play()
		TweenService:Create(btnStroke, TweenInfo.new(0.2), {
			Thickness = 1,
			Transparency = 0.5
		}):Play()
	end)

	btn.MouseButton1Down:Connect(function()
		TweenService:Create(btn, TweenInfo.new(0.1), {
			Size = UDim2.new(0.88, 0, 0, 48)
		}):Play()
	end)

	btn.MouseButton1Up:Connect(function()
		TweenService:Create(btn, TweenInfo.new(0.1), {
			Size = UDim2.new(0.92, 0, 0, 52)
		}):Play()
	end)

	return btn
end

-- ================================================================= --
-- CREATE BUTTONS
-- ================================================================= --

local validateBtn = createButton("Validate Key", 170, 
	Color3.fromRGB(40, 180, 99), 
	Color3.fromRGB(20, 230, 120), 
	"✓")

local getKeyBtn = createButton("Get Key", 240, 
	Color3.fromRGB(52, 152, 219), 
	Color3.fromRGB(41, 128, 185), 
	"🔑")

-- ================================================================= --
-- BUTTON CLICK HANDLERS (REAL KEY LOGIC)
-- ================================================================= --

validateBtn.MouseButton1Click:Connect(function()
	local key = input.Text
	if key == "" then
		notify("Please enter a key!", false)
		-- Shake animation
		for i = 1, 3 do
			TweenService:Create(inputContainer, TweenInfo.new(0.05), {
				Position = UDim2.new(0.05, -5, 0, 100)
			}):Play()
			task.wait(0.05)
			TweenService:Create(inputContainer, TweenInfo.new(0.05), {
				Position = UDim2.new(0.05, 5, 0, 100)
			}):Play()
			task.wait(0.05)
		end
		TweenService:Create(inputContainer, TweenInfo.new(0.05), {
			Position = UDim2.new(0.05, 0, 0, 100)
		}):Play()
	else
		local result = JunkieProtected.ValidateKey({ Key = key })
		if result == "valid" then
			if writefile then
				writefile(KEY_FILENAME, key)
			end
			notify("Key is valid! Welcome.", true)
			gui:Destroy()
			RunMainScript()
		else
			notify("Invalid key. Please try again.", false)
		end
	end
end)

getKeyBtn.MouseButton1Click:Connect(function()
	local link = JunkieProtected.GetKeyLink()
	if setclipboard then
		setclipboard(link)
		notify("Key link copied to clipboard!", true)
	else
		notify("Copy failed. Your executor is not supported.", false)
	end
end)

-- ================================================================= --
-- MAIN WINDOW ENTRANCE ANIMATION
-- ================================================================= --

task.wait(2)

local mainExpand = TweenService:Create(main, 
	TweenInfo.new(0.6, Enum.EasingStyle.Back, Enum.EasingDirection.Out), 
	{Size = UDim2.new(0, 450, 0, 320)})
mainExpand:Play()

mainExpand.Completed:Connect(function()
	local fadeInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

	TweenService:Create(closeBtn, fadeInfo, {BackgroundTransparency = 0.2, TextTransparency = 0}):Play()
	task.wait(0.1)

	TweenService:Create(title, fadeInfo, {TextTransparency = 0}):Play()
	task.wait(0.1)

	TweenService:Create(subtitle, fadeInfo, {TextTransparency = 0}):Play()
	task.wait(0.1)

	TweenService:Create(inputContainer, fadeInfo, {BackgroundTransparency = 0.7}):Play()
	TweenService:Create(inputStroke, fadeInfo, {Transparency = 0.5}):Play()
	TweenService:Create(input, fadeInfo, {TextTransparency = 0}):Play()
	task.wait(0.1)

	TweenService:Create(validateBtn, fadeInfo, {BackgroundTransparency = 0.2, TextTransparency = 0}):Play()
	TweenService:Create(validateBtn:FindFirstChildOfClass("UIStroke"), fadeInfo, {Transparency = 0.5}):Play()
	task.wait(0.1)

	TweenService:Create(getKeyBtn, fadeInfo, {BackgroundTransparency = 0.2, TextTransparency = 0}):Play()
	TweenService:Create(getKeyBtn:FindFirstChildOfClass("UIStroke"), fadeInfo, {Transparency = 0.5}):Play()
end)
