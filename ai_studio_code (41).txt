--[[
  MIST TELEPORT HUB v7.2 (Luxury Final - Full Script)
  - Full GUI + logic: Teleport, AutoBack, Manual Save, Manual TP Back
  - Smooth expand/collapse (pushes list below), button hover/pop uses Size tween
  - Top-center toasts, demo Items auto-created, no overlay
  - Author: Gemini (final v7.2)
  - Added Dynamic UI Scaling
--]]

do
    -- Services
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local Workspace = workspace
    local Lighting = game:GetService("Lighting")

    -- Player refs
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")

    -- GUI identity
    local GUI_NAME = "Mist_TeleportHub_v7_2_full"

    -- Remove old GUI if exists
    local prev = playerGui:FindFirstChild(GUI_NAME)
    if prev then prev:Destroy() end

    -- Theme
    local THEME = {
        bg0 = Color3.fromRGB(12,14,17),
        bg1 = Color3.fromRGB(20,24,33),
        bg2 = Color3.fromRGB(28,33,48),
        text = Color3.fromRGB(235,240,245),
        muted = Color3.fromRGB(160,168,185),
        stroke = Color3.fromRGB(55,62,80),
        accent = Color3.fromRGB(63,120,255), -- royal blue
        ok = Color3.fromRGB(52,211,153),
        warn = Color3.fromRGB(242,201,76),
        err = Color3.fromRGB(239,68,68),
    }
    local ACCENT = THEME.accent
    local SAFE_OFFSET_Y = 4 -- studs above target

    -- State
    local autoSavePos = nil   -- CFrame
    local manualSavePos = nil -- CFrame
    local selectedItem = nil
    local interactiveEnabled = true

    -- Maid for connections/tweens
    local maid = {}
    local activeTweens = {}
    local function bindConn(conn)
        table.insert(maid, conn)
        return conn
    end
    local function safeDisconnectAll()
        for _, c in ipairs(maid) do
            pcall(function() c:Disconnect() end)
        end
        maid = {}
        for obj, tw in pairs(activeTweens) do
            pcall(function() tw:Cancel() end)
            activeTweens[obj] = nil
        end
    end

    local function tween(obj, info, props)
        if activeTweens[obj] then
            pcall(function() activeTweens[obj]:Cancel() end)
            activeTweens[obj] = nil
        end
        local tw = TweenService:Create(obj, info, props)
        activeTweens[obj] = tw
        tw.Completed:Connect(function()
            if activeTweens[obj] == tw then activeTweens[obj] = nil end
        end)
        tw:Play()
        return tw
    end

    local function debounce(fn, wait)
        wait = wait or 0.12
        local last = 0
        local scheduled = false
        local args
        return function(...)
            args = {...}
            last = tick()
            if scheduled then return end
            scheduled = true
            task.spawn(function()
                while tick() - last < wait do task.wait(math.min(0.02, wait/4)) end
                scheduled = false
                fn(unpack(args))
            end)
        end
    end

    -- Helpers
    local function getHRP()
        local ch = player.Character
        if ch then
            return ch:FindFirstChild("HumanoidRootPart")
        end
        return nil
    end

    local function getBaseName(name)
        if not name then return "" end
        name = tostring(name)
        name = name:gsub("%s*[_%-%s]*%d+$", "")
        name = name:gsub("%s+$", "")
        return name
    end

    local function getTargetPart(inst)
        if not inst then return nil end
        if inst:IsA("BasePart") then return inst end
        if inst:IsA("Model") then
            if inst.PrimaryPart then return inst.PrimaryPart end
            local bp = inst:FindFirstChildWhichIsA("BasePart", true)
            if bp then
                pcall(function() inst.PrimaryPart = bp end)
                return bp
            end
        end
        return nil
    end

    local function distanceFromPlayer(inst)
        local hrp = getHRP()
        local part = getTargetPart(inst)
        if hrp and part then
            return (hrp.Position - part.Position).Magnitude
        end
        return math.huge
    end

    -- Toasts (top-center)
    local function makeToastContainer()
        local c = Instance.new("Frame")
        c.Name = "MistToastContainer"
        c.Size = UDim2.new(0, 420, 0, 160)
        c.Position = UDim2.new(0.5, -210, 0, 14)
        c.BackgroundTransparency = 1
        c.Parent = playerGui
        return c
    end
    local toastContainer = makeToastContainer()
    local function notify(text, kind)
        if not toastContainer or not toastContainer.Parent then toastContainer = makeToastContainer() end
        local card = Instance.new("Frame", toastContainer)
        card.Size = UDim2.new(0, 420, 0, 48)
        card.Position = UDim2.new(0, 0, 0, -64)
        card.BackgroundColor3 = THEME.bg2
        card.BackgroundTransparency = 0.03
        card.ClipsDescendants = true
        local cr = Instance.new("UICorner", card); cr.CornerRadius = UDim.new(0,10)
        local st = Instance.new("UIStroke", card); st.Color = THEME.stroke; st.Transparency = 0.6

        local bar = Instance.new("Frame", card)
        bar.Size = UDim2.new(0, 6, 1, 0)
        bar.BackgroundColor3 = (kind == "ok" and THEME.ok) or (kind == "warn" and THEME.warn) or (kind == "err" and THEME.err) or ACCENT

        local label = Instance.new("TextLabel", card)
        label.BackgroundTransparency = 1
        label.Size = UDim2.new(1, -18, 1, 0)
        label.Position = UDim2.new(0, 12, 0, 0)
        label.Font = Enum.Font.SourceSans
        label.TextSize = 15
        label.TextColor3 = THEME.text
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Text = text

        tween(card, TweenInfo.new(0.20, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.new(0, 0, 0, 0), BackgroundTransparency = 0})
        task.delay(2.6, function()
            if card and card.Parent then
                tween(card, TweenInfo.new(0.16, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {Position = UDim2.new(0, 0, 0, -64), BackgroundTransparency = 0.03})
                task.wait(0.18)
                if card then card:Destroy() end
            end
        end)
    end

    -- Build GUI root
    local screen = Instance.new("ScreenGui")
    screen.Name = GUI_NAME
    screen.ResetOnSpawn = false
    screen.Parent = playerGui
    screen.IgnoreGuiInset = true

    -- Dimensions and Responsive Scaling
    local MAIN_W = 460
    local MAIN_H = 520

    --[[ DYNAMIC UI SCALING - START ]]
    local uiScale = Instance.new("UIScale", screen)
    local BASE_SIZE = Vector2.new(MAIN_W, MAIN_H)
    local SCALE_RATIO = 0.85 -- The GUI's height will be this percentage of the screen's shortest side

    bindConn(RunService.RenderStepped:Connect(function()
        local viewport = Workspace.Camera.ViewportSize
        if viewport.X == 0 or viewport.Y == 0 then return end -- Avoid division by zero on startup

        local shortestSide = math.min(viewport.X, viewport.Y)
        -- Calculate scale factor based on the UI's base height and desired screen coverage
        local scaleFactor = (shortestSide * SCALE_RATIO) / BASE_SIZE.Y
        uiScale.Scale = scaleFactor
    end))
    --[[ DYNAMIC UI SCALING - END ]]

    local main = Instance.new("Frame")
    main.Name = "Main"
    main.Size = UDim2.new(0, MAIN_W, 0, MAIN_H)
    main.Position = UDim2.new(0.5, -MAIN_W/2, 0.5, -MAIN_H/2)
    main.BackgroundColor3 = THEME.bg1
    main.BackgroundTransparency = 0.04
    main.Parent = screen
    local mainCorner = Instance.new("UICorner", main); mainCorner.CornerRadius = UDim.new(0,16)
    local mainStroke = Instance.new("UIStroke", main); mainStroke.Color = THEME.stroke; mainStroke.Transparency = 0.54

    -- Header (minimize + close)
    local header = Instance.new("Frame", main)
    header.Size = UDim2.new(1, 0, 0, 48)
    header.BackgroundColor3 = THEME.bg2
    header.BackgroundTransparency = 0.02
    local headerCorner = Instance.new("UICorner", header); headerCorner.CornerRadius = UDim.new(0,16)

    local title = Instance.new("TextLabel", header)
    title.Size = UDim2.new(1, -96, 1, 0)
    title.Position = UDim2.new(0, 16, 0, 0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.SourceSansBold
    title.TextSize = 16
    title.TextColor3 = THEME.text
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Text = "MIST HUB — TELEPORTER (v7.2 Luxury)"

    local headerBtns = Instance.new("Frame", header)
    headerBtns.Size = UDim2.new(0, 80, 1, 0)
    headerBtns.Position = UDim2.new(1, -96, 0, 0)
    headerBtns.AnchorPoint = Vector2.new(0,0)
    headerBtns.BackgroundTransparency = 1

    local function smallBtn(symbol, bg)
        local b = Instance.new("TextButton")
        b.Size = UDim2.new(0, 28, 0, 28)
        b.BackgroundColor3 = bg or THEME.bg1
        b.AutoButtonColor = false
        b.Font = Enum.Font.SourceSansBold
        b.TextSize = 14
        b.TextColor3 = THEME.text
        b.Text = symbol
        local c = Instance.new("UICorner", b); c.CornerRadius = UDim.new(0,8)
        local s = Instance.new("UIStroke", b); s.Color = THEME.stroke; s.Transparency = 0.6
        b.Parent = headerBtns
        return b
    end

    local btnMin = smallBtn("—", THEME.bg1); btnMin.Position = UDim2.new(0, 0, 0.5, -14)
    local btnClose = smallBtn("✕", Color3.fromRGB(200,50,50)); btnClose.Position = UDim2.new(0, 36, 0.5, -14)
    -- spacing reduced and only two buttons

    -- Dragging header
    do
        local dragging = false
        local dragStart, startPos
        bindConn(header.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                dragStart = input.Position
                startPos = main.Position
                local conn
                conn = bindConn(input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                        if conn then conn:Disconnect() end
                    end
                end))
            end
        end))
        bindConn(UserInputService.InputChanged:Connect(function(input)
            if not dragging then return end
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                local delta = input.Position - dragStart
                main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            end
        end))
    end

    -- Search bar - empty
    local searchHolder = Instance.new("Frame", main)
    searchHolder.Size = UDim2.new(1, -28, 0, 40)
    searchHolder.Position = UDim2.new(0, 14, 0, 64)
    searchHolder.BackgroundColor3 = THEME.bg2
    searchHolder.BackgroundTransparency = 0.03
    local searchCorner = Instance.new("UICorner", searchHolder); searchCorner.CornerRadius = UDim.new(0, 10)
    local searchStroke = Instance.new("UIStroke", searchHolder); searchStroke.Color = THEME.stroke; searchStroke.Transparency = 0.6

    local iconSearch = Instance.new("TextLabel", searchHolder)
    iconSearch.Size = UDim2.new(0, 30, 1, 0)
    iconSearch.BackgroundTransparency = 1
    iconSearch.Font = Enum.Font.SourceSans
    iconSearch.Text = "🔎"
    iconSearch.TextColor3 = THEME.muted
    iconSearch.TextSize = 16
    iconSearch.Position = UDim2.new(0, 8, 0, 0)

    local searchBox = Instance.new("TextBox", searchHolder)
    searchBox.Size = UDim2.new(1, -96, 1, 0)
    searchBox.Position = UDim2.new(0, 44, 0, 0)
    searchBox.BackgroundTransparency = 1
    searchBox.Font = Enum.Font.SourceSans
    searchBox.PlaceholderText = "" -- empty
    searchBox.Text = ""
    searchBox.PlaceholderColor3 = THEME.muted
    searchBox.TextSize = 14
    searchBox.TextColor3 = THEME.text
    searchBox.ClearTextOnFocus = false

    local btnClear = Instance.new("TextButton", searchHolder)
    btnClear.Size = UDim2.new(0, 36, 0, 36)
    btnClear.Position = UDim2.new(1, -42, 0, 2)
    btnClear.BackgroundTransparency = 1
    btnClear.Font = Enum.Font.SourceSansBold
    btnClear.Text = "✕"
    btnClear.TextSize = 14
    btnClear.TextColor3 = THEME.muted
    btnClear.AutoButtonColor = false
    btnClear.TextTransparency = 1

    -- Scrolling item list (main file region)
    local listFrame = Instance.new("ScrollingFrame", main)
    listFrame.Size = UDim2.new(1, -28, 1, -236)
    listFrame.Position = UDim2.new(0, 14, 0, 116)
    listFrame.BackgroundTransparency = 1
    listFrame.ScrollBarThickness = 6
    listFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
    listFrame.ClipsDescendants = true
    local listLayout = Instance.new("UIListLayout", listFrame)
    listLayout.Padding = UDim.new(0, 10)
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder

    -- Bottom action area (buttons) - single horizontal UIListLayout so Size changes reflow both sides
    local bottomBar = Instance.new("Frame", main)
    bottomBar.Size = UDim2.new(1, -28, 0, 72)
    bottomBar.Position = UDim2.new(0, 14, 1, -96)
    bottomBar.BackgroundColor3 = THEME.bg2
    bottomBar.BackgroundTransparency = 0.03
    local bc = Instance.new("UICorner", bottomBar); bc.CornerRadius = UDim.new(0, 12)
    local bl = Instance.new("UIListLayout", bottomBar)
    bl.FillDirection = Enum.FillDirection.Horizontal
    bl.SortOrder = Enum.SortOrder.LayoutOrder
    bl.Padding = UDim.new(0, 12)
    bl.VerticalAlignment = Enum.VerticalAlignment.Center
    local pad = Instance.new("UIPadding", bottomBar); pad.PaddingLeft = UDim.new(0, 12); pad.PaddingRight = UDim.new(0, 12)

    -- Button builder with Size tween (so layout updates & siblings shift)
    local function makeButton(text, isPrimary)
        local b = Instance.new("TextButton")
        b.Size = UDim2.new(0.235, 0, 0, 48) -- fits 4 buttons comfortably
        b.BackgroundColor3 = isPrimary and ACCENT or THEME.bg1
        b.AutoButtonColor = false
        b.Font = Enum.Font.SourceSansBold
        b.Text = text
        b.TextSize = 14
        b.TextColor3 = THEME.text
        local corner = Instance.new("UICorner", b); corner.CornerRadius = UDim.new(0, 10)
        local stroke = Instance.new("UIStroke", b); stroke.Color = THEME.stroke; stroke.Transparency = 0.6

        -- glow stroke
        local glow = Instance.new("UIStroke", b)
        glow.Color = ACCENT
        glow.Transparency = 1
        glow.Thickness = 1

        -- hover/leave handlers change Size only (so UIListLayout reflows siblings)
        local hovered = false
        local origSize = b.Size
        local hoverSize = UDim2.new(origSize.X.Scale * 1.05, origSize.X.Offset * 1.05, origSize.Y.Scale * 1.05, origSize.Y.Offset * 1.05)
        b.MouseEnter:Connect(function()
            if hovered then return end
            hovered = true
            tween(b, TweenInfo.new(0.14, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Size = hoverSize})
            tween(glow, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Transparency = 0.2, Thickness = 1.6})
        end)
        b.MouseLeave:Connect(function()
            if not hovered then return end
            hovered = false
            tween(b, TweenInfo.new(0.12, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Size = origSize})
            tween(glow, TweenInfo.new(0.12, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Transparency = 1, Thickness = 1})
        end)

        return b
    end

    local btnTeleport = makeButton("Teleport", true); btnTeleport.Parent = bottomBar
    local btnTPBack = makeButton("TP Back (Auto)", false); btnTPBack.Parent = bottomBar
    local btnManualSave = makeButton("Manual Save", false); btnManualSave.Parent = bottomBar
    local btnManualBack = makeButton("Manual TP Back", false); btnManualBack.Parent = bottomBar

    -- Settings Panel (optional blur)
    local settingsPanel = Instance.new("Frame", main)
    settingsPanel.Size = UDim2.new(0, 220, 0, 0)
    settingsPanel.Position = UDim2.new(1, 12, 0, 60)
    settingsPanel.BackgroundColor3 = THEME.bg2
    settingsPanel.BackgroundTransparency = 0.03
    settingsPanel.Visible = false
    local scorn = Instance.new("UICorner", settingsPanel); scorn.CornerRadius = UDim.new(0,10)
    local sstroke = Instance.new("UIStroke", settingsPanel); sstroke.Color = THEME.stroke; sstroke.Transparency = 0.6

    local lblSettings = Instance.new("TextLabel", settingsPanel)
    lblSettings.Size = UDim2.new(1, -12, 0, 22)
    lblSettings.Position = UDim2.new(0, 8, 0, 8)
    lblSettings.BackgroundTransparency = 1
    lblSettings.Font = Enum.Font.SourceSansBold
    lblSettings.TextSize = 14
    lblSettings.TextColor3 = THEME.text
    lblSettings.TextXAlignment = Enum.TextXAlignment.Left
    lblSettings.Text = "Settings"

    local blurToggle = Instance.new("TextButton", settingsPanel)
    blurToggle.Size = UDim2.new(1, -16, 0, 28)
    blurToggle.Position = UDim2.new(0, 8, 0, 38)
    blurToggle.AutoButtonColor = false
    blurToggle.Font = Enum.Font.SourceSans
    blurToggle.TextSize = 13
    blurToggle.TextColor3 = THEME.text
    blurToggle.Text = "Background Blur: OFF"
    local blurOn = false
    blurToggle.MouseButton1Click:Connect(function()
        blurOn = not blurOn
        blurToggle.Text = "Background Blur: " .. (blurOn and "ON" or "OFF")
        if blurOn then
            local b = Instance.new("BlurEffect")
            b.Name = "Mist_Teleport_Blur"
            b.Size = 0
            b.Parent = Lighting
            tween(b, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = 8})
        else
            local b = Lighting:FindFirstChild("Mist_Teleport_Blur")
            if b then
                tween(b, TweenInfo.new(0.18, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {Size = 0})
                task.delay(0.2, function() if b and b.Parent then b:Destroy() end end)
            end
        end
    end)

    -- Demo Items (auto create Items folder if missing)
    local itemsFolder = Workspace:FindFirstChild("Items")
    if not itemsFolder then
        local ok, err = pcall(function()
            local demo = Instance.new("Folder")
            demo.Name = "Items"
            demo.Parent = Workspace
            local rootPos = (player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position) or Vector3.new(0,5,0)
            local samples = {
                {name = "Sword_1", offset = Vector3.new(8,0,0)},
                {name = "Sword_2", offset = Vector3.new(12,0,10)},
                {name = "HealthPack_1", offset = Vector3.new(-10,0,6)},
                {name = "RareGem_1", offset = Vector3.new(0,0,16)},
                {name = "Legendary_Blade_1", offset = Vector3.new(16,0,-6)},
            }
            for i, v in ipairs(samples) do
                local p = Instance.new("Part")
                p.Size = Vector3.new(1.6,1.6,1.6)
                p.Position = rootPos + v.offset + Vector3.new(0,2,0)
                p.Anchored = true
                p.CanCollide = false
                p.Name = v.name
                p.Parent = demo
            end
            itemsFolder = demo
        end)
        if not ok then
            itemsFolder = nil
            warn("Could not create demo Items:", err)
        end
    end

    -- Accordion: build group rows so expanding pushes below (animate parent frame size)
    local openState = {}
    local groupWidgets = {}

    local function clearList()
        for _, ch in ipairs(listFrame:GetChildren()) do
            if ch ~= listLayout and ch:IsA("GuiObject") then ch:Destroy() end
        end
        groupWidgets = {}
    end

    local function makeChevron()
        local lbl = Instance.new("TextLabel")
        lbl.BackgroundTransparency = 1
        lbl.Size = UDim2.new(0, 20, 1, 0)
        lbl.Font = Enum.Font.SourceSansBold
        lbl.TextSize = 14
        lbl.TextColor3 = THEME.muted
        lbl.Text = "▶"
        return lbl
    end

    local function rotateChevron(chev, expanded)
        if not chev then return end
        local goal = expanded and 90 or 0
        tween(chev, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Rotation = goal})
        tween(chev, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextColor3 = expanded and ACCENT or THEME.muted})
    end

    local function buildGroupRow(groupKey, sortedItems, groupIndex)
        -- Parent wrapper -> this wrapper's Size will be animated so UIListLayout reflows siblings
        local wrapper = Instance.new("Frame")
        wrapper.Size = UDim2.new(1, -4, 0, 40) -- closed height
        wrapper.BackgroundTransparency = 1
        wrapper.LayoutOrder = groupIndex
        wrapper.Parent = listFrame

        local wrapperCorner = Instance.new("UICorner", wrapper); wrapperCorner.CornerRadius = UDim.new(0,8)

        -- header row inside wrapper
        local row = Instance.new("Frame")
        row.Size = UDim2.new(1, 0, 0, 40)
        row.BackgroundColor3 = THEME.bg2
        row.BackgroundTransparency = 0.03
        row.Parent = wrapper
        local rc = Instance.new("UICorner", row); rc.CornerRadius = UDim.new(0, 8)
        local rs = Instance.new("UIStroke", row); rs.Color = THEME.stroke; rs.Transparency = 0.6

        local headerBtn = Instance.new("TextButton", row)
        headerBtn.Size = UDim2.new(1, 0, 1, 0)
        headerBtn.BackgroundTransparency = 1
        headerBtn.Text = ""
        headerBtn.AutoButtonColor = false

        local chev = makeChevron()
        chev.Position = UDim2.new(0, 10, 0, 0)
        chev.Parent = headerBtn

        local nameLbl = Instance.new("TextLabel", headerBtn)
        nameLbl.Position = UDim2.new(0, 34, 0, 0)
        nameLbl.Size = UDim2.new(1, -210, 1, 0)
        nameLbl.BackgroundTransparency = 1
        nameLbl.Font = Enum.Font.SourceSansBold
        nameLbl.TextSize = 14
        nameLbl.TextXAlignment = Enum.TextXAlignment.Left
        nameLbl.TextColor3 = THEME.text
        nameLbl.Text = "  "..groupKey

        local countPill = Instance.new("TextLabel", headerBtn)
        countPill.Size = UDim2.new(0, 46, 0, 22)
        countPill.Position = UDim2.new(1, -170, 0.5, -11)
        countPill.BackgroundColor3 = THEME.bg1
        countPill.Font = Enum.Font.SourceSans
        countPill.TextSize = 12
        countPill.TextColor3 = THEME.text
        countPill.Text = "x"..tostring(#sortedItems)
        local cpCorner = Instance.new("UICorner", countPill); cpCorner.CornerRadius = UDim.new(0,8)
        local cpStroke = Instance.new("UIStroke", countPill); cpStroke.Color = THEME.stroke; cpStroke.Transparency = 0.6

        local distVal = math.huge
        if #sortedItems > 0 then distVal = distanceFromPlayer(sortedItems[1]) end
        local distChip = Instance.new("TextLabel", headerBtn)
        distChip.Size = UDim2.new(0, 86, 0, 22)
        distChip.Position = UDim2.new(1, -112, 0.5, -11)
        distChip.BackgroundColor3 = THEME.bg1
        distChip.Font = Enum.Font.SourceSans
        distChip.TextSize = 12
        distChip.TextColor3 = THEME.muted
        distChip.Text = "["..(distVal == math.huge and "0" or tostring(math.floor(distVal))).." studs]"
        local dc = Instance.new("UICorner", distChip); dc.CornerRadius = UDim.new(0, 8)
        local ds = Instance.new("UIStroke", distChip); ds.Color = THEME.stroke; ds.Transparency = 0.6

        -- children container within wrapper (will be animated)
        local children = Instance.new("Frame", wrapper)
        children.Size = UDim2.new(1, -4, 0, 0)
        children.Position = UDim2.new(0, 0, 0, 40)
        children.ClipsDescendants = true
        children.BackgroundTransparency = 1

        local childLayout = Instance.new("UIListLayout", children)
        childLayout.Padding = UDim.new(0, 8)
        childLayout.SortOrder = Enum.SortOrder.LayoutOrder
        local padd = Instance.new("UIPadding", children); padd.PaddingLeft = UDim.new(0, 8); padd.PaddingRight = UDim.new(0, 8); padd.PaddingTop = UDim.new(0, 8); padd.PaddingBottom = UDim.new(0, 8)

        -- Add the child entries
        for i, inst in ipairs(sortedItems) do
            local part = getTargetPart(inst)
            if part then
                local rowItem = Instance.new("Frame")
                rowItem.Size = UDim2.new(1, 0, 0, 36)
                rowItem.BackgroundColor3 = THEME.bg1
                rowItem.BackgroundTransparency = 0.03
                rowItem.LayoutOrder = i
                rowItem.Parent = children
                local rcorner = Instance.new("UICorner", rowItem); rcorner.CornerRadius = UDim.new(0, 8)
                local rstroke = Instance.new("UIStroke", rowItem); rstroke.Color = THEME.stroke; rstroke.Transparency = 0.6

                local nameLabel = Instance.new("TextLabel", rowItem)
                nameLabel.Size = UDim2.new(1, -160, 1, 0)
                nameLabel.Position = UDim2.new(0, 8, 0, 0)
                nameLabel.BackgroundTransparency = 1
                nameLabel.Font = Enum.Font.SourceSans
                nameLabel.TextSize = 13
                nameLabel.TextColor3 = THEME.text
                nameLabel.TextXAlignment = Enum.TextXAlignment.Left
                nameLabel.Text = inst.Name

                local distLabel = Instance.new("TextLabel", rowItem)
                distLabel.Size = UDim2.new(0, 78, 0, 24)
                distLabel.Position = UDim2.new(1, -180, 0.5, -12)
                distLabel.BackgroundColor3 = THEME.bg2
                distLabel.Font = Enum.Font.SourceSans
                distLabel.TextSize = 12
                distLabel.TextColor3 = THEME.muted
                distLabel.Text = "["..tostring(math.floor(distanceFromPlayer(inst))).."]"
                local dc2 = Instance.new("UICorner", distLabel); dc2.CornerRadius = UDim.new(0, 8)

                local tpBtn = Instance.new("TextButton", rowItem)
                tpBtn.Size = UDim2.new(0, 64, 0, 28)
                tpBtn.Position = UDim2.new(1, -72, 0.5, -14)
                tpBtn.BackgroundColor3 = ACCENT
                tpBtn.AutoButtonColor = false
                tpBtn.Font = Enum.Font.SourceSansBold
                tpBtn.Text = "TP"
                tpBtn.TextSize = 13
                tpBtn.TextColor3 = THEME.text
                local tpc = Instance.new("UICorner", tpBtn); tpc.CornerRadius = UDim.new(0, 8)

                -- hover (background color change)
                rowItem:GetPropertyChangedSignal("BackgroundColor3"):Connect(function() end) -- noop to avoid studio warnings
                rowItem.MouseEnter:Connect(function()
                    tween(rowItem, TweenInfo.new(0.12, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {BackgroundColor3 = THEME.bg2})
                end)
                rowItem.MouseLeave:Connect(function()
                    tween(rowItem, TweenInfo.new(0.12, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {BackgroundColor3 = THEME.bg1})
                end)

                -- select on click
                rowItem.InputBegan:Connect(function(inp)
                    if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then
                        selectedItem = inst
                        notify("Selected: "..inst.Name, "info")
                    end
                end)

                tpBtn.MouseButton1Click:Connect(function()
                    if not interactiveEnabled then notify("Script disabled.", "warn"); return end
                    local hrp = getHRP()
                    if hrp then autoSavePos = hrp.CFrame end
                    local tgt = getTargetPart(inst)
                    if hrp and tgt then
                        hrp.CFrame = CFrame.new(tgt.Position + Vector3.new(0, SAFE_OFFSET_Y, 0))
                        notify("Teleported to: "..inst.Name, "ok")
                    else
                        notify("Invalid target.", "err")
                    end
                end)
            end
        end

        -- Keep references
        groupWidgets[groupKey] = {wrapper = wrapper, children = children, layout = childLayout, headerBtn = headerBtn, chev = chev}

        -- expand/collapse animation (animates wrapper.Size and children.Size)
        local function expand(open)
            local gw = groupWidgets[groupKey]; if not gw then return end
            openState[groupKey] = open and true or false
            rotateChevron(gw.chev, open)
            if open then
                gw.children.Visible = true
                task.spawn(function()
                    task.wait(0.01) -- allow layout to compute
                    local contentH = gw.layout.AbsoluteContentSize.Y + 16 -- padding
                    local targetWrapperH = 40 + contentH
                    tween(gw.wrapper, TweenInfo.new(0.26, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1, -4, 0, targetWrapperH)})
                    tween(gw.children, TweenInfo.new(0.26, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1, -4, 0, contentH)})
                end)
            else
                -- collapse
                tween(gw.children, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Size = UDim2.new(1, -4, 0, 0)})
                tween(gw.wrapper, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Size = UDim2.new(1, -4, 0, 40)})
                task.delay(0.24, function()
                    if gw and gw.children then gw.children.Visible = false end
                end)
            end
        end

        headerBtn.MouseButton1Click:Connect(function()
            expand(not openState[groupKey])
        end)

        -- If content changes size while expanded, re-tween wrapper
        bindConn(childLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
            if openState[groupKey] then
                local gw = groupWidgets[groupKey]
                if gw then
                    local newH = gw.layout.AbsoluteContentSize.Y + 16
                    local targetWrapperH = 40 + newH
                    tween(gw.wrapper, TweenInfo.new(0.20, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1, -4, 0, targetWrapperH)})
                    tween(gw.children, TweenInfo.new(0.20, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1, -4, 0, newH)})
                end
            end
        end))

        -- initial closed
        if openState[groupKey] then expand(true) else groupWidgets[groupKey].children.Visible = false; groupWidgets[groupKey].wrapper.Size = UDim2.new(1, -4, 0, 40) end
    end

    -- Build list from itemsFolder
    local function buildList(filterText)
        clearList()
        filterText = (filterText or ""):lower()
        if not itemsFolder then
            local warnLbl = Instance.new("TextLabel", listFrame)
            warnLbl.BackgroundTransparency = 1
            warnLbl.Size = UDim2.new(1, -12, 0, 34)
            warnLbl.Font = Enum.Font.SourceSans
            warnLbl.TextSize = 14
            warnLbl.TextColor3 = THEME.warn
            warnLbl.Text = "[ERROR] workspace.Items not found."
            return
        end

        local groups = {}
        for _, inst in ipairs(itemsFolder:GetChildren()) do
            local part = getTargetPart(inst)
            if part then
                local base = getBaseName(inst.Name)
                if filterText == "" or base:lower():find(filterText, 1, true) or inst.Name:lower():find(filterText, 1, true) then
                    local d = distanceFromPlayer(inst)
                    groups[base] = groups[base] or {items = {}, closest = math.huge}
                    table.insert(groups[base].items, inst)
                    if d < groups[base].closest then groups[base].closest = d end
                end
            end
        end

        local countGroups = 0
        for _ in pairs(groups) do countGroups = countGroups + 1 end
        if countGroups == 0 then
            local none = Instance.new("TextLabel", listFrame)
            none.BackgroundTransparency = 1
            none.Size = UDim2.new(1, -12, 0, 34)
            none.Font = Enum.Font.SourceSansItalic
            none.TextSize = 14
            none.TextColor3 = THEME.muted
            none.Text = "[No items match search]"
            return
        end

        local arr = {}
        for k, v in pairs(groups) do table.insert(arr, {key = k, data = v}) end
        table.sort(arr, function(a,b) return (a.data.closest or math.huge) < (b.data.closest or math.huge) end)

        for i, entry in ipairs(arr) do
            local key = entry.key
            local listItems = entry.data.items
            table.sort(listItems, function(a,b) return distanceFromPlayer(a) < distanceFromPlayer(b) end)
            buildGroupRow(key, listItems, i)
        end
    end

    -- Debounced search
    local updateSearch = debounce(function()
        buildList(searchBox.Text or "")
        local target = (searchBox.Text ~= "") and 0 or 1
        tween(btnClear, TweenInfo.new(0.14, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {TextTransparency = target})
    end, 0.12)

    bindConn(searchBox:GetPropertyChangedSignal("Text"):Connect(updateSearch))
    btnClear.MouseButton1Click:Connect(function()
        searchBox.Text = ""
        searchBox:CaptureFocus()
        updateSearch()
    end)

    -- Action logic for the 4 buttons
    local function teleportSelected()
        if not interactiveEnabled then notify("Script disabled.", "warn"); return end
        if not selectedItem or not selectedItem.Parent then notify("Select an item first.", "warn"); return end
        local hrp = getHRP()
        local tgt = getTargetPart(selectedItem)
        if hrp and tgt then
            autoSavePos = hrp.CFrame
            hrp.CFrame = CFrame.new(tgt.Position + Vector3.new(0, SAFE_OFFSET_Y, 0))
            notify("Teleported to: "..selectedItem.Name, "ok")
        else
            notify("Invalid target.", "err")
        end
    end

    local function tpBackAuto()
        local hrp = getHRP()
        if hrp and autoSavePos then
            hrp.CFrame = autoSavePos
            notify("Teleported back (Auto).", "ok")
        else
            notify("No Auto Save position.", "warn")
        end
    end

    local function manualSave()
        local hrp = getHRP()
        if hrp then
            manualSavePos = hrp.CFrame
            notify("Manual position saved.", "ok")
        else
            notify("No character found.", "err")
        end
    end

    local function manualTPBack()
        local hrp = getHRP()
        if hrp and manualSavePos then
            hrp.CFrame = manualSavePos
            notify("Teleported to Manual Save.", "ok")
        else
            notify("No Manual Save position.", "warn")
        end
    end

    btnTeleport.MouseButton1Click:Connect(teleportSelected)
    btnTPBack.MouseButton1Click:Connect(tpBackAuto)
    btnManualSave.MouseButton1Click:Connect(manualSave)
    btnManualBack.MouseButton1Click:Connect(manualTPBack)

    -- Header minimize & close
    local minimized = false
    btnMin.MouseButton1Click:Connect(function()
        if minimized then
            tween(main, TweenInfo.new(0.18, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Size = UDim2.new(0, MAIN_W, 0, MAIN_H)})
            listFrame.Visible = true; bottomBar.Visible = true; searchHolder.Visible = true
            minimized = false
        else
            tween(main, TweenInfo.new(0.18, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Size = UDim2.new(0, MAIN_W, 0, 64)})
            listFrame.Visible = false; bottomBar.Visible = false; searchHolder.Visible = false
            minimized = true
        end
    end)

    btnClose.MouseButton1Click:Connect(function()
        safeDisconnectAll()
        local blur = Lighting:FindFirstChild("Mist_Teleport_Blur")
        if blur then blur:Destroy() end
        if toastContainer and toastContainer.Parent then toastContainer:Destroy() end
        if screen and screen.Parent then screen:Destroy() end
    end)

    -- Rebuild list when character spawns and when items change
    bindConn(player.CharacterAdded:Connect(function()
        task.wait(0.12)
        buildList(searchBox.Text)
    end))

    if itemsFolder then
        bindConn(itemsFolder.ChildAdded:Connect(function() updateSearch() end))
        bindConn(itemsFolder.ChildRemoved:Connect(function() updateSearch() end))
    end

    -- Expose updateSearch helper
    function updateSearch() buildList(searchBox.Text or "") end

    -- Initial build
    buildList(searchBox.Text)

    -- Cleanup on destroy
    bindConn(screen.Destroying:Connect(function()
        local blur = Lighting:FindFirstChild("Mist_Teleport_Blur")
        if blur then blur:Destroy() end
        if toastContainer and toastContainer.Parent then toastContainer:Destroy() end
        safeDisconnectAll()
    end))
end